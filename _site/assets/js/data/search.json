[
  
  {
    "title": "Python Tutorial - Chapter 2",
    "url": "/posts/Chapter2/",
    "categories": "Python Tutorials",
    "tags": "python",
    "date": "2024-03-04 00:40:00 +0900",
    





    
    "snippet": "Welcom back to Python Tutorial!Topics covered in this chapter:  list  tuple  set  dictionarySo far, we have seen the following data types in Python, int, float, str, bool. These data types are used...",
    "content": "Welcom back to Python Tutorial!Topics covered in this chapter:  list  tuple  set  dictionarySo far, we have seen the following data types in Python, int, float, str, bool. These data types are used to store a single value. But what if we want to store multiple values in a single variable? This is where Python list comes in.There are four built-in data types in Python that can be used to store multiple values in a single variable. These data types are ‘list’, ‘tuple’, ‘set’, and ‘dictionary’.Python List data typeList is a collection which is ordered and changeable. In Python lists are written with square brackets [].Lists can store any type of data, including other lists. Lists can also store duplicate values.List Example  lists can store any type of datainteger_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]string_list = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\", \"fig\", \"grape\"]boolean_list = [True, False]float_list = [1.1, 2.2, 3.3, 4.4, 5.5]mixed_list = [1, \"apple\", True, 3.3]print(integer_list)print(string_list)print(boolean_list)print(float_list)print(mixed_list)[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig', 'grape'][True, False][1.1, 2.2, 3.3, 4.4, 5.5][1, 'apple', True, 3.3]  lists can store duplicate values or have no values at alldup_list = [1, 2, 2, 3, 3, 3]empty_list = []print(dup_list)print(empty_list)[1, 2, 2, 3, 3, 3][]  lists can store other listssub_list = [\"this\", \"is\", \"a\", \"sub\", \"list\"]super_list = [\"super\", \"list\", sub_list]print(super_list)['super', 'list', ['this', 'is', 'a', 'sub', 'list']]Size of listThe length of a list can be found using the len() function.len function returns the number of items in an object.list1 = [1, 2, 3]size1 = len(list1)print(size1)sub_list = [\"this\", \"is\", \"a\", \"sub\", \"list\"]super_list = [\"super\", \"list\", sub_list]print(len(super_list)) #3print(len(sub_list)) #5335Accessing elements of a list  You can access the elements of a list using the index.A list stores elements in an ordered manner. Each element in a list has an index. The index of the first element is 0, the index of the second element is 1, and so on.Quiz: What will be the output of this code?numbers = [5, 4, 3, 2, 1]number = numbers[0]target = number * numbers[3]print(target)Answernumbers = [5, 4, 3, 2, 1] # index 0, 1, 2, 3, 4number = numbers[0] # 5target = number * numbers[3] # 5 * 2 = 10print(target)10  Negative indexingThe index starts from 0 if you start from the first element. If you want to access element from reversed order, you can start from -1, -2, and so on, instead.words = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\", \"fig\", \"grape\"]# Access the last element of the listn = len(words)print(words[n - 1]) # indexing starts from 0, so the last element is at index n - 1print(words[-1])# Access the second last element of the listprint(words[n - 2])print(words[-2])grapegrapefigfigSlicing a listIf you want to access multiple items from a list, you can use slicing.Slicing is done using the colon :. You can specify the start index and the end index, separated by a colon, to return a part of the list.Specifically, the syntax for slicing is list[start:end].main_list = [1, 2, 3, 4, 5]sub_list = main_list[1:3]print(sub_list) # [2, 3][2, 3]            $ subList = {mainList      index \\in [start, end)}$      sub_list varialbe is a sublist of main_list variable, where index is in the range of $[start, end)$ or $ start \\leq index &lt; end $.You can also specify the step, which allows you to return every n-th item.The syntax for step is list[start:end:step].  If you leave the start index empty, it will start from the beginning.  If you leave the end index empty, it will go to the end.  If you leave the step empty, it will return every item.numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]even_numbers = numbers[1::2] # [2, 4, 6, 8, 10]odd_numbers = numbers[::2] # [1, 3, 5, 7, 9]print(even_numbers)print(odd_numbers)[2, 4, 6, 8, 10][1, 3, 5, 7, 9]Adding and Removing items from list      append(item) method adds an item to the end of the list.        insert(index, item) method adds an item at a specified position.        remove(item) method removes the first occurrence of the specified value.        pop(index) method removes the item at the specified position.        clear() method removes all the items from the list.        extend() method adds the elements of a list to the end of the current list.  # append()numbers = [1, 2, 3, 4, 5]numbers.append(6)print(numbers)[1, 2, 3, 4, 5, 6]# insert()numbers = [1, 2, 4, 5, 6]numbers.insert(2, 3) # insert 3 at index 2print(numbers)[1, 2, 3, 4, 5, 6]# remove()numbers = [1, 1, 1, 2, 2, 2]numbers.remove(1) # remove the first occurrence of 1print(numbers)[1, 1, 2, 2, 2]# pop()numbers = [1, 2, 3, 4, 5]removed = numbers.pop() # remove the last elementprint(numbers)print(f\"the removed item is {removed}\")numbers = [1, 2, 3, 4, 5]removed = numbers.pop(2) # remove the element at index 2print(numbers)print(f\"the removed item is {removed}\")[1, 2, 3, 4]the removed item is 5[1, 2, 4, 5]the removed item is 3# clear()numbers = [1, 2, 3, 4, 5]print(f\"before clear length: {len(numbers)}\")numbers.clear()print(f\"after clear length: {len(numbers)}\")print(numbers)before clear length: 5after clear length: 0[]# extend()numbers = [1, 2, 3]more_numbers = [4, 5, 6]numbers.extend(more_numbers)print(numbers)[1, 2, 3, 4, 5, 6]Quiz: What will be the output of this code?numbers = [1, 2, 3]more_numbers = [4, 5, 6]numbers.extend(more_numbers)more_numbers.extend(numbers)print(more_numbers)Answernumbers variable is updated from [1, 2, 3] to [1, 2, 3, 4, 5, 6]. more_numbers variable is updated from [4, 5, 6] to [4, 5, 6, 1, 2, 3, 4, 5, 6].numbers = [1, 2, 3]more_numbers = [4, 5, 6]numbers.extend(more_numbers) # numbers = [1, 2, 3, 4, 5, 6]more_numbers.extend(numbers) # more_numbers = [4, 5, 6, 1, 2, 3, 4, 5, 6]print(more_numbers)[4, 5, 6, 1, 2, 3, 4, 5, 6]Modify items in a listYou can change the value of a specific item by referring to its index number.Quiz: What will be the output of this code?bools = [True, False, True, False]bools[1] = Trueprint(bools)Answerbools = [True, False, True, False]bools[1] = True # change the second element to Trueprint(bools)[True, True, True, False]You can also change a range of items in a list by using slicing.numbers = [1, 2, 3, 3, 3]numbers[3:] = [4, 5, 6, 7, 8, 9, 10] # replace the last three elements with 4, 5, 6print(numbers)[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]TupleA tuple is a collection which is ordered and unchangeable. In Python tuples are written with round brackets ().tuple is similar to list, but the main difference is that tuple is immutable.Tuple Examplemy_tuple = (1, 2, 3, 4, 5)print(len(my_tuple)) # 5print(my_tuple)print(my_tuple[0]) # 1print(my_tuple[-1]) # 5print(my_tuple[1:4]) # (2, 3, 4)5(1, 2, 3, 4, 5)15(2, 3, 4)my_tuple.pop()my_tuple.append(6)my_tuple[0] = 6All of the above code will result in an error, because tuple is immutable and does not support item assignment, item deletion, or item addition.SetA set is a collection which is unordered and unindexed. In Python sets are written with curly brackets {}. It is similar to $set {}$ in mathematics.The core characteristics of a set are that the elements are unordered, unindexed, and do not allow duplicate values.Set Examplemy_set = {1, 2, 3, 4, 5, 5, 5, 5, 5, 5}len(my_set) # 5print(my_set) # {1, 2, 3, 4, 5}, the duplicates are removed5{1, 2, 3, 4, 5}my_set = {1, 2, 3, 4, 5, 5, 5, 5, 5, 5}my_set.add(6)print(my_set) # {1, 2, 3, 4, 5, 6}my_set.remove(1)print(my_set) # {2, 3, 4, 5, 6}{1, 2, 3, 4, 5, 6}{2, 3, 4, 5, 6}set1 = {1, 2, 3, 4, 5}set2 = {4, 5, 6, 7, 8}set3 = set1.union(set2)print(set3) # {1, 2, 3, 4, 5, 6, 7, 8}set4 = set1.intersection(set2)print(set4) # {4, 5}set5 = set1.symmetric_difference(set2)print(set5) # {1, 2, 3, 6, 7, 8}{1, 2, 3, 4, 5, 6, 7, 8}{4, 5}{1, 2, 3, 6, 7, 8}Let $ set1 = {1, 2, 3, 4, 5} $ and $ set2 = {4, 5, 6, 7, 8} $  The union of $ set1 $ and $ set2 $ is represented as:$ set3 = set1 \\cup set2 = {1, 2, 3, 4, 5, 6, 7, 8} $  The intersection of $ set1 $ and $ set2 $ is represented as:$ set4 = set1 \\cap set2 = {4, 5} $  The symmetric difference of $ set1 $ and $ set2 $ is represented as:$ set5 = set1 \\bigtriangleup set2 = set1 \\cup set2 - set1 \\cap set2 = {1, 2, 3, 6, 7, 8} $Casting between list, tuple, and setYou can convert the data types between list, tuple, and set using the following functions:  list()  tuple()  set()# from list to tuple and setmy_list = [1, 2, 3, 4, 5]my_tuple = tuple(my_list)my_set = set(my_list)print(f\"list: {my_list}\")print(f\"tuple: {my_tuple}\")print(f\"set: {my_set}\")list: [1, 2, 3, 4, 5]tuple: (1, 2, 3, 4, 5)set: {1, 2, 3, 4, 5}# from tuple to list and setmy_tuple = (1, 2, 3, 4, 5, 5, 5)my_list = list(my_tuple)my_list.append(6)my_set = set(my_tuple) # removes the duplicatesprint(f\"list: {my_list}\")print(f\"tuple: {my_tuple}\")print(f\"set: {my_set}\")list: [1, 2, 3, 4, 5, 5, 5, 6]tuple: (1, 2, 3, 4, 5, 5, 5)set: {1, 2, 3, 4, 5}# from set to list and tuplemy_set = {1, 2, 3, 4, 5, 5, 5}my_list = list(my_set)my_tuple = tuple(my_set)print(f\"list: {my_list}\")print(f\"tuple: {my_tuple}\")print(f\"set: {my_set}\")list: [1, 2, 3, 4, 5]tuple: (1, 2, 3, 4, 5)set: {1, 2, 3, 4, 5}DictionaryA dictionary is a collection which is unordered, changeable, and indexed. In Python dictionaries are written with curly brackets {}, and they have keys and values.Dictionary is different from the other data types in that it is a collection of key-value pairs. Each key is separated from its value by a colon :. The items are separated by commas ,.Dictionary Exampleexample_dict = {    \"job\" : \"programmer\",    \"age\" : 21,    \"major\": \"Computer Science\",    \"grades\": [90, 98, 89, 100],    \"is_student\": True}  keys: “job”, “age”, “major”, “grades”, “is_student”  values: “programmer”, 21, “computer science”, [90, 98, 89, 100], Truekeys work similar to index in list and tuple, but keys can be any immutable data type, such as int, float, str, tuple, and bool.To access the values, you can use the key, just like you use the index in a list or a tuple.example_dict = {1: \"integer\", 2.5: \"float\", \"key\": \"string\", (1, 2): \"tuple\", False: \"boolean\"}print(example_dict)print(example_dict[1]) # integerprint(example_dict[2.5]) # floatprint(example_dict[\"key\"]) # stringprint(example_dict[(1, 2)]) # tupleprint(example_dict[False]) # boolean{1: 'integer', 2.5: 'float', 'key': 'string', (1, 2): 'tuple', False: 'boolean'}integerfloatstringtuplebooleanModify DictionaryQuiz: What will be the output of this code?dict1 = {    1: \"one\",    2: \"two\",    3: \"three\",    4: \"four\"}dict1.pop(1)dict1[3] = \" \"dict1[5] = \"five\"print(dict1)Answerdict1 = {    1: \"one\",    2: \"two\",    3: \"three\",    4: \"four\"}dict1.pop(1) # remove the key-value pair with key 1dict1[3] = \" \" # update the value of key 3 to an empty stringdict1[5] = \"five\" # add a new key-value pair to the dictionaryprint(dict1){2: 'two', 3: ' ', 4: 'four', 5: 'five'}Other operations on Dictionarydict1 = {    1: \"one\",    2: \"two\",    3: \"three\",    4: \"four\"}dict2 = {    5: \"five\",    6: \"six\",    7: \"seven\"}print(f\"use len() function to get the length of the dictionary: {len(dict1)}\") # 4dict3 = {**dict1, **dict2} # merge the two dictionariesprint(f\"merged dictionary: {dict3}\")dict2.clear() # clear the dictionaryprint(f\"dict2 after clear: {dict2}\")dict2.update(dict1) # update dict2 with the key-value pairs from dict1print(f\"dict2 after update: {dict2}\")use len() function to get the length of the dictionary: 4merged dictionary: {1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five', 6: 'six', 7: 'seven'}dict2 after clear: {}dict2 after update: {1: 'one', 2: 'two', 3: 'three', 4: 'four'}Practice ProblemsProblems  Create a list of integers from 1 to 10 in ascending order, then reverse the list, and print the reversed list.Hint: Use slicing: list[start:end:step]  Given a tuple of integers, find how many duplicate values are in the tuple, and return a list that consists of the same numbers in the tuple, but without duplicates.Example:# inputmy_tuple = (10, 11, 13, 13, 17, 10, 20, 21, 2, 2, 2, 2)# outputThere are 5 duplicate items in the tuple.list: [10, 11, 13, 17, 20, 21, 2]  You, as a teacher, finished grading your students’ work and updated their final grade. However, right before submitting the grades, you discovered that one of your students, “ Joseph “, cheated on the exam. You are very upset and decided to give him a final grade of 0 and mark him “failed”. You also noticed that you made a small mistake, and you accidently swapped the subjects of “ Edward “ and “ Jennifer “. You need to fix the mistake and update their grades too.Question: Given the dictionary of the students, update the information according to the passage.students = {    \"Joseph\" : {        \"subject\" : \"Mathematics\",        \"grade\" : 98.9,        \"pass\" : True    },    \"Edward\" : {        \"subject\" : \"Physics\",        \"grade\" : 89.5,        \"pass\" : True    },    \"Jennifer\" : {        \"subject\" : \"Chemistry\",        \"grade\" : 90.0,        \"pass\" : True    }}AnswerAnswer 1numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]reversed_numbers = numbers[::-1]print(reversed_numbers)[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]Answer 2my_tuple = (10, 11, 13, 13, 17, 10, 20, 21, 2, 2, 2, 2)my_set = set(my_tuple)len_tuple = len(my_tuple)len_set = len(my_set)duplicate_count = len_tuple - len_setmy_list = list(my_set)print(f\"There are {duplicate_count} duplicate items in the tuple.\")print(f\"list: {my_list}\")There are 5 duplicate items in the tuple.list: [2, 10, 11, 13, 17, 20, 21]Answer 3# given dictionarystudents = {    \"Joseph\" : {        \"subject\" : \"Mathematics\",        \"grade\" : 98.9,        \"pass\" : True    },    \"Edward\" : {        \"subject\" : \"Physics\",        \"grade\" : 89.5,        \"pass\" : True    },    \"Jennifer\" : {        \"subject\" : \"Chemistry\",        \"grade\" : 90.0,        \"pass\" : True    }}#students[\"Joseph\"][\"pass\"] = False# Edward and Jeniffer swap subjectsstudents[\"Edward\"][\"subject\"], students[\"Jennifer\"][\"subject\"] = students[\"Jennifer\"][\"subject\"], students[\"Edward\"][\"subject\"]print(students[\"Joseph\"])print(students[\"Edward\"])print(students[\"Jennifer\"]){'subject': 'Mathematics', 'grade': 98.9, 'pass': False}{'subject': 'Chemistry', 'grade': 89.5, 'pass': True}{'subject': 'Physics', 'grade': 90.0, 'pass': True}"
  },
  
  {
    "title": "Sorting Algorithms (Part 1)",
    "url": "/posts/sorting1/",
    "categories": "Programming, Algorithm",
    "tags": "algorithm, programming, python, c++",
    "date": "2024-02-16 14:16:00 +0900",
    





    
    "snippet": "This is a fourth post in Algorithm series.IntroductionSorting is the process of arranging a collection of data in a particular order. The most common orders are numerical order and lexicographical ...",
    "content": "This is a fourth post in Algorithm series.IntroductionSorting is the process of arranging a collection of data in a particular order. The most common orders are numerical order and lexicographical order. Sorting is a fundamental operation in computer science and is used in many applications. For example, sorting is used to organize data for efficient searching, to prepare data for presentation, and to optimize data for storage and retrieval.In this post, we’ll discuss the algorithms for sorting an array. There are many sorting algorithms, but in this post, I will introduce the two most popular algorithms:  Bubble Sort  Insertion SortBubble SortBubble sort is probably the simplest sorting algorithm. It works by repeatedly stepping through the list, comparing each pair of adjacent items, and swapping them if they are in the wrong order. The pass through the list is repeated until the list is sorted.Assume there is an unsorted array arr = [32, 1, 9, 6] and we want to sort it in ascending order.Bubble Sort will work as follows:  Compare the first two elements of the array. If the first element is greater than the second element, swap them.[32, 1, 9, 6] -&gt; [1, 32, 9, 6]  Compare the second and third elements of the array. If the second element is greater than the third element, swap them.[1, 32, 9, 6] -&gt; [1, 9, 32, 6]  Compare the third and fourth elements of the array. If the third element is greater than the fourth element, swap them.[1, 9, 32, 6] -&gt; [1, 9, 6, 32]  Repeat the process until the array is sorted.[1, 9, 6, 32] -&gt; [1, 9, 6, 32] (1 &lt; 9)[1, 9, 6, 32] -&gt; [1, 6, 9, 32] (9 &gt; 6)[1, 6, 9, 32] -&gt; [1, 6, 9, 32] (9 &lt; 32)PerformanceThe time complexity of the bubble sort algorithm is ${O(n^2)}$.In the worst case, the algorithm will have to repeat the sorting process $n^2$ times, where $n$ is the number of elements in the list.  pros:          It is simple and easy to implement.      It is effective for small datasets.        cons:  It is not the most efficient algorithm.  It may take a long time for large datasets.PseudocodeThe pseudocode for the bubble sort algorithm is as follows:function bubble_sort(list):    for each element in the list:        for each adjacent pair of elements:            if the first element is greater than the second element:                swap the elementsImplementationHere is a simple implementation of the bubble sort algorithm:void bubble_sort(int arr[], int size;){    for(int i = 0; i &lt; size; i++){        for(int j = 0; j &lt; size - i - 1; j++){            if(arr[j] &gt; arr[j + 1]){                int temp = arr[j];                arr[j] = arr[j + 1];                arr[j + 1] = temp;            }        }    }}def bubble_sort(arr):    length = len(arr) - 1    for i in range(length):        for j in range(length - i):            if arr[j] &gt; arr[j + 1]:                arr[j], arr[j + 1] = arr[j + 1], arr[j]    return arrNote that the length is len(arr) - 1, and the range is length - i.This is because we are comparing arr[j] and arr[j + 1], and we don’t want to compare the last element with the element after it. len(arr) - 1 prevents the comparison going out of range.After each pass, the largest element will be at the end of the array, so we don’t need to compare it again. length - i prevents the comparison of the sorted elements.ApplicationBubble sort is not the most efficient algorithm, yet it can be used for datasets consisting of data types that are not numeric, such as strings or characters.Bubble sort is a Stable sort, which means that the relative order of equal elements is preserved in the sorted output.Insertion SortInsertion sort is a simple sorting algorithm that works the way we sort playing cards in our hands. It works by building a sorted array one element at a time.Imagine there are two bundles of cards. One bundle is sorted, and the other is not. We pick one card from the unsorted bundle and insert it into the correct position in the sorted bundle. We repeat this process until the unsorted bundle is empty.Assume there is an unsorted array arr = [6, 5, 8, 2] and we want to sort it in ascending order.Insertion Sort will work as follows:  We start with the second element of the array, and we compare it with the first element. If the second element is smaller than the first element, we swap them.[6, 5, 8, 2] -&gt; [5, 6, 8, 2] (6 &gt; 5)  Next, we compare the third element with the second element[5, 6, 8, 2] -&gt; [5, 6, 8, 2] (6 &lt; 8)There is no need to compare the third element with the first element because the first and second elements are already sorted.  We compare the fourth element with the third element[5, 6, 8, 2] -&gt; [5, 6, 2, 8] (8 &gt; 2)We compare the fourth element with the second element[5, 6, 2, 8] -&gt; [5, 2, 6, 8] (6 &gt; 2)We compare the fourth element with the first element[5, 2, 6, 8] -&gt; [2, 5, 6, 8] (5 &gt; 2)  The array is sorted.PerformanceThe time complexity of the insertion sort algorithm is ${O(n^2)}$.In the worst case, the algorithm will have to repeat the sorting process $n^2$ times, where $n$ is the number of elements in the list.Although the time complexity of the insertion sort algorithm is the same as the bubble sort algorithm, the insertion sort algorithm is more efficient than the bubble sort algorithm.If the array is mostly sorted, the insertion sort will perform much faster than the bubble sort.  pros:          It is simple and easy to implement.      It is effective for small datasets.      It is more efficient than the bubble sort algorithm.        cons:  It is not the most efficient algorithm.  It may take a long time for large datasets.PseudocodeThe pseudocode for the insertion sort algorithm is as follows:function insertion_sort(list):    for each element in the list:        value = the element        while the index is greater than 0 and the previous element is greater than the value:            move the previous element to the next position            decrease the indexImplementationHere is a simple implementation of the insertion sort algorithm:void insertion_sort(int arr[], int size){    for(int i = 1; i &lt; size; i++){        int value = arr[i];        int j = i - 1;        while(j &gt;= 0 &amp;&amp; arr[j] &gt; value){ //if the previous element is greater            arr[j + 1] = arr[j]; // the next element is replaced with the previous value            j--;        }        arr[j + 1] = value; // the temporary value is placed in the correct position    }}def insertion_sort(arr):    for i in range(1, len(arr)):        value = arr[i]        j = i - 1 # j is the previous index        while j &gt;= 0 and arr[j] &gt; value:            arr[i] = arr[j]            i -= 1        arr[i] = valueApplicationInsertion sort is a simple and efficient algorithm for small datasets. It is also used in practice for datasets that are mostly sorted.Insertion sort is a Stable sort, which means that the relative order of equal elements is preserved in the sorted output."
  },
  
  {
    "title": "Hash Table",
    "url": "/posts/HashTable/",
    "categories": "Programming, Data Structure",
    "tags": "algorithm, datastructure, programming, python, dictionary",
    "date": "2024-02-15 12:03:00 +0900",
    





    
    "snippet": "This is a fifth post in Data Structure series.IntroductionAssociate Array is an abstract data type that stores a value with a key associated with it. In a simpler term, it is a collection of Key-Va...",
    "content": "This is a fifth post in Data Structure series.IntroductionAssociate Array is an abstract data type that stores a value with a key associated with it. In a simpler term, it is a collection of Key-Value Pairs. The key is used to access the elements in the collection. The key is mapped to a value, and the value can be retrieved by providing the key. The key is unique, and it is used to identify the value. The value can be anything, such as a string, integer, or even a complex data structure.A dictionary in Python is an example of an associate array.A hash table is a linear data structure that implements an associative array abstract data type, a structure that can map keys to values. A hash table uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found. Python dictionaries are implemented using hash tables.A hash function receives a key as a parameter and returns a has value, the index of the array where the value is stored in.hash_function(key) -&gt; hash_value -&gt; index -&gt; array[index] = valueHash FunctionA hash function is a function that takes an input (or ‘key’) and returns a fixed-size string of bytes. The output is typically a fixed-size string of bytes or a fixed-size integer. The output is called the hash value.For example, a simple hash function can be defined as follows:def hash_function(key, arr):    return key % len(arr)The above hash function returns the remainder of the key divided by the length of the array, where the values will be stored.Imagine we have an array of size 7, and have the following keys to store: 21, 29, 86, 38, 39, 40, 9021 % 7 = 029 % 7 = 186 % 7 = 238 % 7 = 339 % 7 = 440 % 7 = 590 % 7 = 6arr = [21, 29, 86, 38, 39, 40, 90]CollisionSo far, the example array arr = [21, 29, 86, 38, 39, 40, 90] has no problem. However, consider the case we receive more keys: 30, 23, 2, 6.```30 % 7 = 223 % 7 = 22 % 7 = 26 % 7 = 6```The returned index are already filled with other values. This is called a collision.To solve this problem, we can use a technique called chaining.Chaining is a technique that allows multiple items to be stored in the same slot of the hash table. Each slot contains a linked list of items. When a collision occurs, the item is added to the linked list at the slot.arr = [21, 29, [86, 30, 23, 2], 38, 39, 40, [90, 6]]arr[0] = 21arr[1] = 29arr[2] = [86, 30, 23, 2]arr[3] = 38arr[4] = 39arr[5] = 40arr[6] = [90, 6]To find the value of the key 23, we can use the hash function to find the index of the array, and then search the inside list to find the value.Performance  Unlike other data structures, the operations search, insert, and delete have a time complexity of $O(1)$ on average.  Hash Table is the most efficient data structure for searching, inserting, and deleting elements, especially for large datasets.  Accessing n th element is not possible in a hash table.Implementing a hash table is the most efficient way for searching, and no other searching algorithms can be faster than $O(1)$.Hash tables are used widely all accross the developing sectors.For example, the JSON (JavaScript Object Notation) data format is a widely used data interchange format. It is used to store and transmit data between a server and a web application. Using API, JSON can be easily converted to a dictionary in Python.The key-value DBMS (Database Management System) is another example of a hash table. It is used to store and retrieve data in a database.The version control system Git also uses a hash table to store the content of the files.If there is a large dataset, and we need to search, insert, or delete elements, the hash table is the best data structure to use.If we need to manipulate data in order or have to access the n th element, then we should use other data structures such as an array, or linked list.ImplementationTo implement a practical hash table data structure, we can use multiple arrays, where one array stores the keys at the index calculated by the hash function, and the other array stores the associated values at the same index.There is no need to implement a hash table from scratch in Python, as Python already has a built-in dictionary data structure.hash_table = {}hash_table['one'] = 1hash_table['two'] = 2hash_table['three'] = 3for key in hash_table:    print(f\"{key}: {hash_table[key]}\")Problem SolvingCharacters in a StringGiven a string, write a function to count the number of times each character appears in the string.We can solve this problem using a dictionary in Python. We can use the character as the key and the count as the value.def countChar(word: str) -&gt; dict:    char_count = {}    for char in word:        if char in char_count:            char_count[char] += 1 # if there is corresponding key, increase the value by 1        else:            char_count[char] = 1 # if there is no corresponding key, create a new key and associate a value of 1    return char_countSum of Two NumbersGiven an array of integers, and a target number, write a function to return the indices of the two numbers that add up to the target number. We can assume that there is only one solution, and the same element cannot be used twice.For exampleinput = [-1, 2, 3, 4, 7]target = 5input[1] + input[2] = 2 + 3 = 5output = [1, 2]There are multiple ways to solve this problem.  Brute Forcedef findSum(nums: list, target: int) -&gt; list:    for i in range(len(nums)):        for j in range(len(nums)):            if i != j and nums[i] + nums[j] == target:                return [i, j]    return []This solution has a time complexity of $O(n^2)$, and it is not efficient.We can approach this problem using a hash table data structure.def twoSum(nums: list, target: int) -&gt; list:    num_dict = {}    for index, n in enumerate(nums):        rem = target - n        if rem in num_dict:            return [num_dict[rem], index]        else:            num_dict[n] = indexnum_dict = {}First, we create an empty dictionary to keep track of the index of the elements in the input list.Later in this dictionary, the key will be the elements of the input list, and the value will be the index of the elements.for index, n in enumerate(nums):    rem = target - nUsing the enumerate function, we can iterate through the list and get the index and the value of the element. After that, we assign the value of target - n to the variable rem.if rem in num_dict:    return [num_dict[rem], index]If the value of rem is already in the dictionary, we return the index of the value of rem and the current index.This is because rem = target - n, thus target = rem + n. If the rem value is already in the dictionary, we can access the value associated with the rem key (which is the index from the input list), and the current index to get the indices of the two numbers that add up to the target number.else:    num_dict[n] = indexIf the value of rem is not in the dictionary, we add the current value n to the dictionary with the index as the value, and move on to the next iteration."
  },
  
  {
    "title": "Queue",
    "url": "/posts/queue/",
    "categories": "Programming, Data Structure",
    "tags": "algorithm, datastructure, programming, python, list",
    "date": "2024-02-14 16:00:00 +0900",
    





    
    "snippet": "This is a fourth post in Data Structure series.IntroductionA queue is a linear data structure that follows the First In First Out (FIFO) principle. It is similar to a line of people waiting for a b...",
    "content": "This is a fourth post in Data Structure series.IntroductionA queue is a linear data structure that follows the First In First Out (FIFO) principle. It is similar to a line of people waiting for a bus. The person who comes first will get into the bus first. Just like Stacks, Queue is considered a Limited-Access Data Structure. Queue is a similar Abstract Data Type (ADT) to stack, with only difference being the replacement of LIFO (Last In First Out) with FIFO.OperationsQueue consists of two main operations.  Enqueue: Adds an item to the queue. If the queue is full, then it is said to be an Overflow condition.  Dequeue: Removes an item from the queue. The items are popped in the same order in which they are pushed. If the queue is empty, then it is said to be an Underflow condition.Types of Queue  Bounded Queue: A queue with a fixed size.  Unbounded Queue: A queue with no fixed size.Performance  Enqueue and Dequeue operations both have a time complexity of O(1).  Queues are efficient for adding and removing elements, but not for searching or accessing elements in the middle.Queue is a very useful data structure in programming. It is ideal for scenarios where data is processed in a first come first serve basis.For example, a call center phone system uses a queue to hold people in line until a service representative is free. The person who has been waiting the longest is the first to be served.Buffering is another scenario where queue is used. Data is transferred between two devices, and at the receiving end, data is kept in a queue until the device is ready to accept it.You can imagine a queue being utilized in video streaming services. The streaming device will receive the video data from a server and store it in a queue until it is ready to be displayed.ImplementationA common way to implement a queue is to use an array. However, since an array has a fixed size, there is a limitation to implement an unbounded queue with an array. To overcome this limitation, we can use a linked list to implement a queue.Here is a simple implementation of a queue using a linked list in Python:class Node:    def __init__(self, data, next=None):        self.data = data        self.next = nextclass Queue:    def __init__(self):        self.front = None        self.rear = None        self._size = 0    def enqueue(self, item):        self._size += 1        node = Node(item)        if self.rear is None:            self.front = node            self.rear = node        else:            self.rear.next = node            self.rear = node    def dequeue(self):        if self.front is None:            raise IndexError(\"The queue is empty\")        self._size -= 1        temp = self.front        self.front = self.front.next        if self.front is None:            self.rear = None        return temp.data    def size(self):        return self._sizedef __init__(self):    self.front = None # The first element of the queue    self.rear = None # The last element of the queue    self._size = 0This is a constructor for the Queue class. It initializes an empty queue, so the first and last elements are set to None, and the size is set to 0.def enqueue(self, item):    self._size += 1    node = Node(item)    if self.rear is None:        self.front = node        self.rear = node    else:        self.rear.next = node # The current rear node points to the new node        self.rear = node # The rear is updated to the new nodeThis is the enqueue method. Becuase the item is added to the queue, the size increases by 1.A new node is created with the item, and was empty, the new Node becomes the only itme in the Queue. In that case, both the front and rear are set to the new node.If the queue was not empty, the prior rear node receives a new pointer that links to the new node. After this, the rear is updeated to the new node.def dequeue(self):    if self.front is None:        raise IndexError(\"The queue is empty\")    self._size -= 1    temp = self.front    self.front = self.front.next    if self.front is None:        self.rear = None    return temp.dataThis is the dequeue method. The size of the queue is decreased by 1.If the Queue is empty, an error is raised.If the Queue is not empty, the front node is stored in a temporary variable. After that, the second element in the queue is updated to be the new front.If the front becomes None after the dequeue, it implies that the Queue is now empty. In this case, the rear is also set to None.The method returns the data of the original front node, which is unlinked from the queue.demonstrationqueue = Queue()print(f\"Size of queue: {queue.size()}\")queue.enqueue(3)queue.enqueue(5)queue.enqueue(7)print(f\"Size of queue: {queue.size()}\")for i in range(queue.size()):    print(queue.dequeue())print(f\"Size of queue: {queue.size()}\")Size of queue: 0Size of queue: 3357Size of queue: 0In Python, there is a built-in module called queue that provides a Queue class. The Queue class uses a linked list to implement a queue. The following code demonstrates how to use the Queue class.from queue import Queueq = Queue()print(f\"Size of queue: {q.qsize()}\")q.put(3)q.put(5)q.put(7)print(f\"Size of queue: {q.qsize()}\")for i in range(q.qsize()):    print(q.get())print(f\"Size of queue: {q.qsize()}\")Size of queue: 0Size of queue: 3357Size of queue: 0Problem Solving1. Reverse a QueueGiven a queue, reverse it.def reverse_queue(queue):    stack = []    while not queue.empty():        stack.append(queue.get())    while stack:        queue.put(stack.pop())The above code uses a stack to reverse the queue. The queue is emptied and the elements are pushed into the stack. After that, the elements are popped from the stack and pushed back into the queue.2. Create a Queue using StacksImplement a queue using two stacks.class Queue:    def __init__(self):        self.stack1 = []        self.stack2 = []    def enqueue(self, item):        while len(self.stack1) != 0:            self.stack2.append(self.stack1.pop())        self.stack1.append(item)        while len(self.stack2) != 0:            self.stack1.append(self.stack2.pop())    def dequeue(self):        if len(self.stack1) == 0:            raise IndexError(\"The queue is empty\")        return self.stack1.pop()Stacks add item in the front, while Queue adds item in the rear.To emulate enqueue method, we need to take out all the items from a stack, add the new item, and then put back all the items in order.def enqueue(self, item):    while len(self.stack1) != 0: # while stack1 is not empty        self.stack2.append(self.stack1.pop()) # take out all the items from stack1 and put them in stack2    self.stack1.append(item) # add the new item to stack1    while len(self.stack2) != 0: # while stack2 is not empty        self.stack1.append(self.stack2.pop()) # take out all the items from stack2 and put them back in stack1To emulate dequeue method, we can simply pop the last item from stack1This is because both stacks and queues have the item to be removed at the top/front of the data structure.The only difference is that the candidate for removal was added the most recently in a stack, while it was added the least recently in a queue."
  },
  
  {
    "title": "Stacks",
    "url": "/posts/stack/",
    "categories": "Programming, Data Structure",
    "tags": "algorithm, datastructure, programming, python, list, c++",
    "date": "2024-02-14 14:15:00 +0900",
    





    
    "snippet": "This is a third post in Data Structure series.IntroductionA stack is a linear data structure that follows the Last In First Out (LIFO) principle. This means that the last element added to the stack...",
    "content": "This is a third post in Data Structure series.IntroductionA stack is a linear data structure that follows the Last In First Out (LIFO) principle. This means that the last element added to the stack will be the first one to be removed. Since the stack data structure must follow the order of insertion and deletion, it is also classified as a Limited-Access Data Structure.OperationsStacks often have two main opperations.  Push: Adds an element to the stack.  Pop: Removes the last element added to the stack.Types of Stacks  Unbound Stacks: These stacks have no limit on the number of elements that can be added to them. They can grow and shrink as needed.  Bounded Stacks: These stacks have a limit on the number of elements that can be added to them. Once the limit is reached, no more elements can be added to the stack.Performance  The push and pop operations both have a time complexity of O(1).  Stacks are efficient for adding and removing elements, but not for searching or accessing elements in the middle.Stack is one of the most used data structures in computer science. In languages like Python and Java, the internal stacks are used to manage function calls. Compliers use stacks to interpret the expressions like double parenthesis. In the real world, stacks are used in the undo feature in text editors, back button in web browsers, undo and redo features, etc.ImplementationsWe can use a variety of existing data structures to implement a stack abstract data type.An Abstract Data Type (ADT) is like a blueprint for a data structure. When the idea of a ADT is implemented, it finally becomes a data structure.The most common ways to implement a stack are using arrays and linked lists.Array ImplementationUsing array to implement a Bounded Stackclass Stack {    private int[] stack;    private int top;    private int capacity;    Stack(int size) {        stack = new int[size];        capacity = size;        top = -1;    }    public void push(int element) {        if (top == capacity - 1) {            System.out.println(\"Stack is full\");            return;        }        stack[++top] = element;    }    public int pop() {        if (top == -1) {            System.out.println(\"Stack is empty\");            return -1;        }        return stack[top--];    }    public int peek() {        if (top == -1) {            System.out.println(\"Stack is empty\");            return -1;        }        return stack[top];    }    public boolean isEmpty() {        return top == -1;    }}#include &lt;iostream&gt;using namespace std;class Stack {    private:        int *stack;        int top;        int capacity;    public:        Stack(int size) {            stack = new int[size];            capacity = size;            top = -1;        }        void push(int element) {            if (top == capacity - 1) {                cout &lt;&lt; \"Stack is full\" &lt;&lt; endl;                return;            }            stack[++top] = element;        }        int pop() {            if (top == -1) {                cout &lt;&lt; \"Stack is empty\" &lt;&lt; endl;                return -1;            }            return stack[top--];        }        int peek() {            if (top == -1) {                cout &lt;&lt; \"Stack is empty\" &lt;&lt; endl;                return -1;            }            return stack[top];        }        bool isEmpty() {            return top == -1;        }};# Python uses list instead of array, and thus the stack is unboundedclass Stack:    def __init__(self):        self.stack = []    def push(self, element): # Add element to the top of the stack        self.stack.append(element)    def pop(self):        if len(self.stack) == 0: # If stack is empty, return error message            return \"Stack is empty\"        return self.stack.pop() # Remove and return the top element of the stack    def peek(self):        if len(self.stack) == 0:            return \"Stack is empty\"        return self.stack[-1] # Return the top element of the stack    def is_empty(self):        return len(self.stack) == 0 # Return True if stack is empty, False otherwise    def size(self):        return len(self.stack)    def __str__(self):        return str(self.stack)demonstrationstack = Stack()print(stack.is_empty()) # Truestack.push(1)stack.push(2)stack.push(3)print(stack.is_empty()) # Falseprint(stack.peek()) # 3print(stack.size()) # 3print(stack) # [1, 2, 3]Linked List ImplementationUsing linked list to implement an Unbounded Stackclass Node {    int data;    Node next;    Node(int data) {        this.data = data;        this.next = null;    }}class Stack {    private Node top;    public void push(int element) {        Node newNode = new Node(element);        newNode.next = top;        top = newNode;    }    public int pop() {        if (top == null) {            System.out.println(\"Stack is empty\");            return -1;        }        int data = top.data;        top = top.next;        return data;    }    public int peek() {        if (top == null) {            System.out.println(\"Stack is empty\");            return -1;        }        return top.data;    }    public boolean isEmpty() {        return top == null;    }}#include &lt;iostream&gt;using namespace std;class Node {    public:        int data;        Node *next;        Node(int data) {            this-&gt;data = data;            this-&gt;next = NULL;        }};class Stack {    private:        Node *top;    public:        void push(int element) {            Node *newNode = new Node(element);            newNode-&gt;next = top;            top = newNode;        }        int pop() {            if (top == NULL) {                cout &lt;&lt; \"Stack is empty\" &lt;&lt; endl;                return -1;            }            int data = top-&gt;data;            top = top-&gt;next;            return data;        }        int peek() {            if (top == NULL) {                cout &lt;&lt; \"Stack is empty\" &lt;&lt; endl;                return -1;            }            return top-&gt;data;        }        bool isEmpty() {            return top == NULL;        }};# Singly linked listclass Node:    def __init__(self, data):        self.data = data        self.next = Noneclass Stack:    def __init__(self):        self.head = None    def push(self, data): # Add element to the top of the stack        node = Node(data)        if self.head is None:            self.head = node # If the stack is empty, the new node is the head        else:            node.next = self.head # The new node points to the current head            self.head = node # The new node is the new head    def pop(self):        if self.head is None:            raise IndexError(\"pop from empty stack\")        poppendnode = self.head        self.head = self.head.next # The first element is unlinked (= removed) from the stack        return poppendnode.datademonstrationstack = Stack()stack.push(1)stack.push(2)print(stack.pop()) # 2print(stack.pop()) # 1Problem SolvingReverse a StringReversing a string using a stack is a classic problem. We can use a stack to push all the characters of the string and then pop them to get the reversed string.Note that for Python, we will be using the list stack for the solution.#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;string reverseString(string str) {    stack&lt;char&gt; s;    for (char c : str) {        s.push(c);    }    string reversed = \"\";    while (!s.empty()) {        reversed += s.top();        s.pop();    }    return reversed;}There are multiple solutions in Python.# Method 1word = \"hello\"revWord = word[::-1]print(reversed) # olleh# Method 2word = \"hello\"revWord = ''.join(reversed(word))print(revWord) # olleh# Method 3 (using stack implemented with array)def reverse_string(word: str) -&gt; str:    stack = Stack()    revWord = \"\"    for c in word:        stack.push(c) # first loop to add elements to the stack    while not stack.is_empty(): # second loop to remove elements from the stack        revWord += stack.pop()    return revWordprint(reverse_string(\"hello\")) # ollehCheck Balanced ParenthesesGiven a string of parentheses, we have to check if the string has balanced parentheses. A string has balanced parentheses if every opening parenthesis has a corresponding closing parenthesis and they are in the correct order.This can be done by two counters. The first method is to use two counters to keep track of the openeing and closing parentheses.#include &lt;iostream&gt;#include &lt;string&gt;using std::string;using std::cout;int main() {    void checkParentheses(string str){        int open = 0;        int close = 0;        for (char c : str) {            if (c == '(') {                open++;            } else if (c == ')') {                close++;            }        }        if (open == close) {            cout &lt;&lt; \"Balanced\" &lt;&lt; endl;        } else {            cout &lt;&lt; \"Not Balanced\" &lt;&lt; endl;        }    }}def check_parentheses(s):    open = 0    close = 0    for c in s:        if c == '(':            open += 1        elif c == ')':            close += 1    if open == close:        return \"Balanced\"    else:        return \"Not Balanced\"However, there is a problem with this approach. Imange with the input string word = \")()(\". There are two opeining and two closing parentheses each. The above code will return “Balanced”, yet this string starts with a closing parenthesis, which is not balanced.Using stack resolves the issue while solving the problem more wisely.The logic is quite simple. We will iterate through the string and if the character is an opening parenthesis, we will push it to the stack. If the character is a closing parenthesis, we will pop the top element from the stack.If the function attempts to pop from an empty stack, we will return “Not Balanced”. This is because the closing parenthesis does not have a corresponding opening parenthesis.def checkParentheses(word: str) -&gt; bool:    stack = Stack()    for c in word:        if c == \"(\":            stack.push(c)        elif c == \")\":            if stack.is_empty():                return False            stack.pop()    return stack.is_empty()def test_checkParentheses():    cases = [        (\"((()))\", True),        (\"((())\", False),        (\"())\", False),        (\"()\", True),        (\")(\", False),        (\"\", True)    ]    for i, (input, expected) in enumerate(cases, start=1):        result = checkParentheses(input)        if result == expected:            print(f\"Case {i} passed\")        else:            print(f\"Case {i} failed\")test_checkParentheses()Case 1 passedCase 2 passedCase 3 passedCase 4 passedCase 5 passedCase 6 passed"
  },
  
  {
    "title": "Searching Algorithms",
    "url": "/posts/searching/",
    "categories": "Programming, Algorithm",
    "tags": "algorithm, programming, python, c++, recursion",
    "date": "2024-02-14 10:39:00 +0900",
    





    
    "snippet": "This is a third post in Algorithm series.In this post, we'll discuss the algorithms for searching an element inan array. There are many searching algorithms, but in this post, I willintroduce the t...",
    "content": "This is a third post in Algorithm series.In this post, we'll discuss the algorithms for searching an element inan array. There are many searching algorithms, but in this post, I willintroduce the two most popular algorithms:  Linear Search  Binary SearchIntroductionSearching is the process of finding a particular element from acollection of data. Thanks to the built in functions in most programminglanguages like Python, programmers rarely need to implement thesearching algorithms on their own. However, understanding thesealgorithms is a first step to understanding sophisticated algorithms andmove further.Linear SearchLinear search is the simplest searching algorithm that searches for anelement in a list in sequential order. It is also known as a sequentialsearch. It is a brute-force algorithm that checks each element of thelist until a match is found or the whole list has been searched.PerformanceThe time complexity of the linear search algorithm is ${O(n)}$.This is because in the worst case, the algorithm will have to repeat thesearching process n times, where n is the number of elements in thelist.  pros:          It is simple and easy to implement.      It is effective for small datasets.      The list does not need to be sorted.        cons:          It is not the most efficient algorithm.      It may take a long time for large datasets.      PseudocodeThe pseudocode for the linear search algorithm is as follows:function linear_search(list, target):    for each element in the list:        if the element is equal to the target:            return the index of the element    return -1ImplementationHere is a simple implementation of the linear search algorithm inPython:def linear_search(arr, target):    for i in range(len(arr)):        if arr[i] == target:            return i    return -1Here is a simple implementation of the linear search algorithm in C++:int linear_search(int arr[], int target){    int n = sizeof(arr)/sizeof(arr[0]);    for(int i = 0; i &lt; n; i++){        if(arr[i] == target){            return i;        }    } return -1;}ExampleLet's consider an example to understand the linear search algorithm.Suppose we have a list of numbers:arr = [5, 3, 8, 6, 2, 7, 1, 4]We want to search for the number 7 in the list. The linear searchalgorithm will search for the number 7 in the list and return the indexof the number if it is found. If the number is not found, the algorithmwill return -1.arr = [5, 3, 8, 6, 2, 7, 1, 4]target = 7print(linear_search(arr, target)) # Output: 5The algorithm starts to compare the target with each element of thelist. When it finds the number 7 at index 5, it returns the index 5.Binary SearchBinary search is a fast searching algorithm with a time complexity of${O(\\log n)}$. It is a divide and conquer algorithm that works on asorted array. It repeatedly divides the search interval in half andcompares the target value to the middle element of the array. If themiddle element is equal to the target, then the search is successful. Ifthe middle element is greater than the target, then the search continuesin the left half of the array. If the middle element is less than thetarget, then the search continues in the right half of the array.PerformanceThe time complexity of the binary search algorithm is ${O(\\log n)}$.This is because the algorithm divides the list in half at eachiteration, which reduces the search interval by half at each step.  pros:          It is efficient for large datasets.      It is faster than linear search.        cons:          The list must be sorted.      It is not effective for small datasets.      PseudocodeThe pseudocode for the binary search algorithm is as follows:function binary_search(arr, target):    left = 0    right = length of arr - 1    while left &lt;= right:        mid = (left + right) // 2        if arr[mid] == target:            return mid        elif arr[mid] &lt; target:            left = mid + 1        else:            right = mid - 1    return -1ImplementationHere is a simple implementation of the binary search algorithm inPython:def binary_search(arr, target):    left = 0    right = len(arr) - 1    while left &lt;= right:        mid = (left + right) // 2        if arr[mid] == target:            return mid        elif arr[mid] &lt; target:            left = mid + 1        else:            right = mid - 1    return -1Here is a simple implementation of the binary search algorithm in C++:int binary_search(int arr[], int target){    int n = sizeof(arr)/sizeof(arr[0]);    int left = 0;    int right = n - 1;    while(left &lt;= right){        int mid = (left + right) / 2;        if(arr[mid] == target){            return mid;        } else if(arr[mid] &lt; target){            left = mid + 1;        } else {            right = mid - 1;        }    } return -1;}ExampleLet's consider an example to understand the binary search algorithm.Suppose we have a sorted list of numbers:arr = [1, 2, 3, 4, 5, 6, 7, 8]We want to search for the number 6 in the list. The binary searchalgorithm will compare the target with the middle element of the listand drop the unnecessary half of the list. This process will continueuntil the target is found or the list is empty. If the number is found,the algorithm will return the index of the number. If the number is notfound, the algorithm will return -1.left = 0right = len(arr) - 1 # length of the input list - 1 = 7# in the first iteration:mid = (left + right) // 2 # (0 + 7) // 2 = 3arr[mid] = 4 # arr[3] = 4arr[mid] &lt; target # 4 &lt; 6Because the middle element is less than the target, there is no need toinvestigate the left half. The algorithm will continue to search in theright half of the list.left = mid + 1 # 3 + 1 = 4right = 7# in the second iteration:mid = (left + right) // 2 # (4 + 7) // 2 = 5arr[mid] = 6 # arr[5] = 6arr[mid] == target # 6 == 6Recursive Binary SearchAs the example above implies, the binary search algorithm is arepetition of the same process. This makes it a good candidate for arecursive implementation. Here is a simple implementation of the binarysearch algorithm using recursion:def binary_search(arr, target, left = 0, right = None):    if right is None:        right = len(arr) - 1    if left &lt;= right:        mid = (left + right) // 2        if arr[mid] == target:            return mid        elif arr[mid] &lt; target:            return binary_search(arr, target, mid + 1, right) # search in the right half        else:            return binary_search(arr, target, left, mid - 1) # search in the left half    return -1int binary_search(int arr[], int target, int left = 0, int right = -1){    int n = sizeof(arr)/sizeof(arr[0]);    if(right == -1){        right = n - 1;    }    if(left &lt;= right){        int mid = (left + right) / 2;        if(arr[mid] == target){            return mid;        } else if(arr[mid] &lt; target){            return binary_search(arr, target, mid + 1, right);        } else {            return binary_search(arr, target, left, mid - 1);        }    } return -1;}"
  },
  
  {
    "title": "Linked List",
    "url": "/posts/linkedList/",
    "categories": "Programming, Data Structure",
    "tags": "algorithm, datastructure, programming, python, list",
    "date": "2024-02-12 23:23:00 +0900",
    





    
    "snippet": "This is a second post in Data Structure series.IntroductionA linked list is a linear data structure where each element is a separate object.A linked list, like an array, can store, add, remove, and...",
    "content": "This is a second post in Data Structure series.IntroductionA linked list is a linear data structure where each element is a separate object.A linked list, like an array, can store, add, remove, and search for data. However, an element in a linked list is not stored continuously in memory and does not have an index.A linked list stores data in node. Each node consist of two parts: data and a reference to the next node in the sequence.The first node is called the head and the last node is called the tail. The tail node is the node that has a reference to None.A linked list is a dynamic data structure, which means that the size of the list can change during the execution of the program. Also, the size and the type of the data can be vary in a linked list.Types of Linked List  Singly linked list: Each node contains a data and a reference to the next node.  Doubly linked list: Each node contains a data and two references to the next and previous node.  Circular linked list: Last node contains a reference to the first node as the next node and the first node has a reference to the last node as the previous node.Performance of a Linked List      A linked list, unlike an array, does not have to push every single element to a new memory for inserting a new element. It only needs to change the reference of the previous node to the new node.        Since a linked list does not have an index, searching for an element in a linked list is slower than an array. To find an element in a linked list, the program has to traverse the list from the head to the tail.        A linked list must contain a reference to the next node, so it uses more memory than an array.  Linked List Classbelow is a Python implementation of a singly linked list.Implementationclass Node:    def __init__(self, data, next=None):        self.data = data # data        self.next = next # reference to the next node (this is a pointer)class LinkedList:    def __init__(self):        self.head = None    def __str__(self):        node = self.head        while node is not None:            print(node.data)            node = node.next        return \"\"    def append(self, data):        if self.head is None:            self.head = Node(data)            return        current = self.head        while current.next:            current = current.next        current.next = Node(data)    def search(self, data):        current = self.head        posistion = 0        while current is not None:            if current.data == data:                return posistion            posistion += 1            current = current.next        return -1    def remove(self, target):        if self.head.data == target:            self.head = self.head.next            return        current = self.head        prev = None        while current is not None:            if current.data == target:                prev.next = current.next                return            prev = current            current = current.next        raise ValueError(\"Value not found in the list\")    def insert(self, target, data):        new_node = Node(data)        if self.head.data == target:            new_node.next = self.head.next            self.head.next = new_node            return        current = self.head        while current:            if current.data == target:                new_node.next = current.next                current.next = new_node                return            current = current.next        raise ValueError(\"Value not found in the list\")    def update(self, old, new):        if self.head.data == old:            self.head.data = new            return        current = self.head        while current:            if current.data == old:                current.data = new                return            current = current.next        raise ValueError(\"Value not found in the list\")    def len(self):        current = self.head        count = 0        while current:            count += 1            current = current.next        return count    def reverse(self):        current = self.head        prev = None        while current:            next = current.next            current.next = prev            prev = current            current = next        self.head = prevMethods Explained      Node Class    The Node class is a blueprint for a node in a linked list. It contains two parts: data and a reference to the next node.    class Node:    def __init__(self, data, next=None):        self.data = data # data        self.next = next # reference to the next node (this is a pointer)        Constructor    The constructor initializes the head of the linked list.    def __init__(self):    self.head = None    By default, the head is None because the linked list is empty.        str Method    The __str__ method is called when print() is called on an object. This method returns a string representation of the linked list.    def __str__(self):    node = self.head    while node is not None:        print(node.data)        node = node.next    return \"\"    while node is not None:    If the node has not reached the end of the linked list, print(node.data) prints the data of the current node and updates the node to the next node.        append Method    The append method adds a new node to the end of the linked list.    def append(self, data):    new_node = Node(data)    if self.head is None:        self.head = new_node        return    last_node = self.head    while last_node.next:        last_node = last_node.next    last_node.next = new_node    new_node = Node(data)    Creates a new node with the given data.    if self.head is None:    self.head = new_node    return    If the linked list is empty, the new node becomes the head of the linked list.    last_node = self.headwhile last_node.next:    last_node = last_node.next    If the linked list is not empty, the program traverses the linked list to find the last node.While the next node is not None, the program updates the last_node to the next node.    last_node.next = new_node    When the last node is found, the next node of the last node is updated to the new node.        search method    The search method searches for a node with the given data in the linked list and returns the position of the node.    def search(self, data):    current = self.head    posistion = 0    while current is not None:        if current.data == data:            return posistion        posistion += 1        current = current.next    return -1    current = self.headposistion = 0    Initially, the current is the head of the linked list and the posistion is 0.    while current is not None:    if current.data == data:        return posistion    While the current is not None, the program checks if the data of the current node is equal to the target data.If the data is found, the method returns the position of the node.    posistion += 1current = current.next    If the data does not match the target data, the position is incremented by 1 and the current is updated to the next node.    return -1    If the target data is not found in the linked list, the method returns -1.        remove method    The remove method removes the data from the linked list.    def remove(self, target):    if self.head.data == target:        self.head = self.head.next        return    current = self.head    prev = None    while current is not None:        if current.data == target:            prev.next = current.next            return        prev = current        current = current.next    raise ValueError(\"Value not found in the list\")    if self.head.data == target:    self.head = self.head.next    return    If the first data is the target data, the head of the list is updated to the next node.    current = self.headprev = None    If the first data is not the target data, the current is the head of the linked list and the prev is None.    while current is not None:    if current.data == target:        prev.next = current.next        return    prev = current    current = current.next    While the list has not reached the end, the program checks if the data of the current node is equal to the target data.If the target data is found, the previous node updates its pointer so that it skips the target node and points to the next node.If current data does not match the target data, the previous node and the current node moves one step forward.    raise ValueError(\"Value not found in the list\")    If the target data is not found in the linked list, the method raises a ValueError.        insert method    The insert method receives two parameters target and data. The method inserts a new node with the given data after the node with the target data.    def insert(self, target, data):    new_node = Node(data)    if self.head.data == target:        new_node.next = self.head.next        self.head.next = new_node        return    current = self.head    while current:        if current.data == target:            new_node.next = current.next            current.next = new_node            return        current = current.next    raise ValueError(\"Value not found in the list\")    The insertion works by updating the pointers of the existing nodes.The pointer of the target node is updated to reference the new node, and the pointer of the new node is the original pointer of the target node, before the insertion.    new_node.next = self.head.nextself.head.next = new_nodereturnnew_node.next = current.nextcurrent.next = new_nodereturn    These codes perform the updating process.    new_node = Node(data)    The method starts by creating a new nmode with the given data.    if self.head.data == target:    new_node.next = self.head.next    self.head.next = new_node    return    If the target data is the first data, the new node is inserted after the head of the linked list.    while current:    if current.data == target:        new_node.next = current.next        current.next = new_node        return    current = current.next    If the first data is not the target data, it traverses the linked list by updating the current to the next node.When the target data is found, the insertion is performed.    raise ValueError(\"Value not found in the list\")    If the target data is not found in the linked list, the method raises a ValueError.        update method    The update method receives two parameters target and data. The method updates the data of the node with the target data to the new data.    def update(self, old, new):    if self.head.data == old:        self.head.data = new        return    current = self.head    while current:        if current.data == old:            current.data = new            return        current = current.next    raise ValueError(\"Value not found in the list\")    if self.head.data == old:    self.head.data = new    return    If the first data is the target data, the data of the head node is updated to the new data.    while current:    if current.data == old:        current.data = new        return    current = current.next    If the first data is not the target data, the program traverses the linked list by updating the current to the next node.When the target data is found, the data of the node is updated to the new data.    raise ValueError(\"Value not found in the list\")    If the target data is not found in the linked list, the method raises a ValueError.        len method    The len method returns the length of the linked list.    def __len__(self):    current = self.head    count = 0    while current:        count += 1        current = current.next    return count    current = self.headcount = 0    Initially, the current is the head of the linked list and the count is 0.    while current:    count += 1    current = current.next    While the list has not reached the end, the program increments the count by 1 and updates the current to the next node.    return count    When the end of the linked list is reached, the method returns the count.        reverse method    The reverse method reverses the order of the linked list.    def reverse(self):    current = self.head    prev = None    while current:        next = current.next        current.next = prev        prev = current        current = next    self.head = prev    current = self.headprev = None    Initially, the current is the head of the linked list and the prev is None.    while current:    next = current.next    current.next = prev    prev = current    current = next    While the list has not reached the end, the program reverses the order of the linked list by updating the pointers of the nodes.For example, lets say we have the following linked list:    1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5        The reverse method works as follows: 0. current = 1 and prev = None          next = current.next The next node is saved in the next variablenext = 2      current.next = prev The next node is replaced with the previous node2 -&gt; None      prev = current The prev variable is updated to the current nodeprev = 1      current = next The current variable is updated to the next nodecurrent = 2              The process is repeated until the end of the linked list is reached.        1 -&gt; None2 -&gt; 1 -&gt; None3 -&gt; 2 -&gt; 1 -&gt; None4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; None5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; None                    "
  },
  
  {
    "title": "Array",
    "url": "/posts/array/",
    "categories": "Programming, Data Structure",
    "tags": "algorithm, datastructure, programming, python, list",
    "date": "2024-02-12 23:23:00 +0900",
    





    
    "snippet": "This is a first post in Data Structure series.IntroductionAn array is a collection of items stored at contiguous memory locations. The idea is to store multiple items of the same type together. Thi...",
    "content": "This is a first post in Data Structure series.IntroductionAn array is a collection of items stored at contiguous memory locations. The idea is to store multiple items of the same type together. This makes it easier to calculate the position of each element by simply adding an offset to a base value, i.e., the memory location of the first element of the array (generally denoted by the name of the array).Characteristics of Arrays  Homogeneous Data Structures: a single array can only consist of a single type of data#include &lt;stdio.h&gt;int main(){    // Homogeneuous Data Structure    int nums[5] = {1, 2, 3, 4, 5}; // valid    int numbers[3] = {1.2, 1, 'C'}; // invalid    return 0;}  Static Data Structures: Once an array is created, the number of spaces is fixed#include &lt;iostream&gt;int main(){    // Static Data Structure    int nums[3];    nums = {1, 2, 3, 4}; // array size exceeded    nums = {1, 2, 3}; // valid    return 0;}Indexing Arrays      Elements in an array are accessible by the index of the array.        Most programming languages start indexing from 0, instead of 1. (Exceptions: R, Matlab, Fortran, etc)        The memory address of the first element of an array is called the Base Address        Formula for the memory address of the elements:Base_addres + index * size_of_data_type  One Dimensional Array#include &lt;stdio.h&gt;int main() {    // Create a one-dimensional array of integers    int nums[5] = {1, 2, 3, 4, 5};    // accessing the index of the array    for(int i = 0; i &lt; 5; i++) {        printf(\"%d \", nums[i]);    }    return 0;}Multi-Dimensional Array#include &lt;stdio.h&gt;int main() {    // Create a two-dimensional array    int nums[2][3] = {{1, 2, 3}, {4, 5, 6}};    // Accessing the index of the array    printf(\"%d \", nums[0][2]); // 3    // Create a three-dimensional array    int numbers[2][2][3] = {{{1, 2, 3}, {4, 5, 6}}, {{7, 8, 9}, {10, 11, 12}}};    // Accessing the index of the array    printf(\"%d \", numbers[0][1][2]); // 6    return 0;}Performance of an Array      An array is efficient for accessing and modifying an element.        An array is inefficient to insert an element; it has to push every single element existing later than the inserted element  Array in PythonNote that list is different from an array data structure.Creating array using array module in Pythonimport arrayarr = array.array('i', [1, 2, 3, 4, 5]) # Need to specify the data types inside the arrayfor i in range(len(arr)):    print(arr[i])12345However, it is more useful to use list in Python!Problem SolvingQuestion 1.Move all the zeros to the back of a list, while leaving the non-zero elements in their original position.Example:[8, 0, 3, 0, 12] -&gt; [8, 3, 12, 0, 0]Python Code Solutiondef move_zeros(nums):    zero_index = 0    for index, n in enumerate(nums): # enumerate function allows to look at the index and the element together        if n!= 0:            nums[zero_index] = n            if zero_index != index:                nums[index] = 0            zero_index += 1    return numsnums = [8, 0, 3, 0, 12]move_zeros(nums)print(nums)[8, 3, 12, 0, 0]Algorithm Explanation  Since this algorithm consists of one loop for checking the elements of the list, the time complexity of this algorithm is $O(n)$Input List: [8, 0, 3, 0, 12]  first iterationzero_index = 0index = 0n = 8if n!= 0: # n= 8    nums[zero_index] = n # nums[0] = 8    if zero_index != index: #zero_index == index        -    zero_index += 1 #zero_index = 1[8, 0, 3, 0, 12]  second iterationzero_index = 1index = 1n = 0if n!= 0: # n == 0    -[8, 0, 3, 0, 12]  third iterationzero_index = 1index = 2n = 3if n!= 0: # n == 3    nums[zero_index] = n # [8, 3, 3, 0, 12]    if zero_index != index: # 1 != 2        nums[index] = 0 # [8, 3, 0, 0, 12]    zero_index += 1 # zero_index = 2[8, 3, 0, 0, 12]...[8, 3, 12, 0, 0]Question 2.Merging two listsExample:product_list = [\"milk\", \"chips\", \"pencile\"]price_list = [1000, 1500, 500]# Merge the two listsresult = [(\"milk\", 1000),    (\"chips\", 1500),    (\"pencile\", 500)]Python Solutiondef merge_list(list1, list2):    return list(zip(list1, list2))product_list = [\"milk\", \"chips\", \"pencile\"]price_list = [1000, 1500, 500]result = merge_list(product_list, price_list)print(result)[('milk', 1000), ('chips', 1500), ('pencile', 500)]Question 3.find duplicates in a listPython Code SolutionThe problem can be solved by iterating twice $O(n^{2})$Using Set in python allows the problem to solve with the time complexity of $O(n)$def find_dups(arr):    dups = [] # an empty list to store duplicate data    a_set = set() # an empty set, note that sets do not allow duplicates    for item in arr:        l1 = len(a_set) # size of the set before adding an item        a_set.add(item) # item will be added to the set only if there is no same data in the set        l2 = len(a_set) # size of the set after adding an item        if l1 == l2: # two sizes are the smae -&gt; the item was not added -&gt; item is duplicate            dups.append(item)    return dupsnames = [\"Jack\", \"Adam\", \"Philips\", \"Jack\"] # Jack is duplicatedups = find_dups(names)print(dups)['Jack']"
  },
  
  {
    "title": "Euler's Formula",
    "url": "/posts/Euler_Eq/",
    "categories": "Mathematics, Calculus",
    "tags": "euler, complex, math, trigonometry, calculus, imaginary number",
    "date": "2024-02-11 18:03:00 +0900",
    





    
    "snippet": "IntroductionIn this post, I will be introducing one of the most famous formulas in mathematics, Euler’s Formula. Euler’s Formula is a mathematical formula that establishes the fundamental relations...",
    "content": "IntroductionIn this post, I will be introducing one of the most famous formulas in mathematics, Euler’s Formula. Euler’s Formula is a mathematical formula that establishes the fundamental relationship between the trigonometric functions and the complex exponential function. It is often cited as an example of deep mathematical beauty.Having completed up to Calculus II is recommended.Prerequsites:  Basic understanding in complex plane  Basic understanding in trigonometric functions  Understanding in Talyer Series Expansion  Understanding in single variable differentiationEuler’s FormulaEuler’s Formula is given by:\\[e^{i\\theta} = \\cos(\\theta) + i\\sin(\\theta)\\]where:  \\(e\\) is the base of the natural logarithm  \\(i\\) is the imaginary unit  \\(\\theta\\) is the angle in radiansThis formula provides a valuable connection between complex numbers and trigonometry. It is often used to simplify trigonometric identities and to solve differential equations.DerivationThe formula can be derived using the Taylor series expansion of the exponential function, sine function, and cosine function.Taylor Series ExpansionAn Euler’s Identity \\(e^{i\\theta} = \\cos(\\theta) + i\\sin(\\theta)\\) can be derived using the Taylor series expansion of the exponential function, sine function, and cosine function.RecallThe Taylor series expansion of a function \\(f(x)\\) about a point \\(a\\) is given by:\\[f(x) = \\sum_{n=0}^{\\infty} \\frac{f^{(n)}(a)}{n!} \\cdot (x - a)^n\\]and      Taylor Series Expansion of the \\(f(x) = e^x\\) is given by: \\(e^x = \\sum_{n=0}^{\\infty} \\frac{x^n}{n!}\\)        Taylor Series Expansion of the \\(f(x) = \\sin(x)\\) is given by: \\(\\sin(x) = \\sum_{n=0}^{\\infty} \\frac{(-1)^n \\cdot x^{2n+1}}{(2n+1)!}\\)        Taylor Series Expansion of the \\(f(x) = \\cos(x)\\) is given by: \\(\\cos(x) = \\sum_{n=0}^{\\infty} \\frac{(-1)^n \\cdot x^{2n}}{(2n)!}\\)  where the radius of convergence of the three functions is \\(R \\in (-\\infty, \\infty)\\).ProofThe Taylor series expansion of the function \\(e^{i\\theta}\\) is given by:\\[\\begin{align*}e^{i\\theta} &amp;= \\sum_{n=0}^{\\infty} \\frac{(i\\theta)^n}{n!} \\\\&amp;= 1 + i\\theta + \\frac{(i\\theta)^2}{2!} + \\frac{(i\\theta)^3}{3!} + \\frac{(i\\theta)^4}{4!} + \\cdots \\\\&amp;= 1 + i\\theta - \\frac{\\theta^2}{2!} - i\\frac{\\theta^3}{3!} + \\frac{\\theta^4}{4!} + i\\frac{\\theta^5}{5!} - \\cdots \\\\&amp;= \\left(1 - \\frac{\\theta^2}{2!} + \\frac{\\theta^4}{4!} - \\cdots\\right) + i\\left(\\theta - \\frac{\\theta^3}{3!} + \\frac{\\theta^5}{5!} - \\cdots\\right) \\\\&amp;= \\cos(\\theta) + i\\sin(\\theta)\\end{align*}\\]&nbsp;$$\\therefore e^{i\\theta} = \\cos(\\theta) + i\\sin(\\theta)$$VerificationWe can verify the formula by simple derivatives.\\(e^{i\\theta} = \\cos(\\theta) + i\\sin(\\theta)\\)&nbsp;Let$$f_1(\\theta) = e^{i\\theta}$$$$f_2(\\theta) = \\cos(\\theta) + i\\sin(\\theta)$$Then$$\\frac{d}{d\\theta} f_1(\\theta) = \\frac{d}{d\\theta} (e^{i\\theta}) = ie^{i\\theta} = if_1(\\theta)$$and$$\\frac{d}{d\\theta} f_2(\\theta) = -\\sin(\\theta) + i\\cos(\\theta) = i[-\\sin(\\theta) + \\cos(\\theta)] = i[\\cos(\\theta) + i\\sin(\\theta)] = if_2(\\theta)$$both functions satisfy the following equation: $$\\frac{d}{dx} f(x) = if(x)$$Differentiate the quotient of \\( f_1(\\theta) \\) and \\( f_2(\\theta) \\):$$\\frac{d}{d\\theta} \\left[ \\frac{f_1(\\theta)}{f_2(\\theta)} \\right] = \\frac{f'_1(\\theta)f_2(\\theta) - f_1(\\theta)f'_2(\\theta)}{[f_2(\\theta)]^2}$$$$= \\frac{i f_1(\\theta) f_2(\\theta) - f_1(\\theta) \\cdot i f_2(\\theta)}{[f_2(\\theta)]^2} = 0$$Therefore$$\\frac{d}{d\\theta} \\left[ \\frac{f_1(\\theta)}{f_2(\\theta)} \\right] = 0$$A derivative being zero implies that$$\\frac{f_1(\\theta)}{f_2(\\theta)} = c$$for some constant \\( c \\).&nbsp;To find the value of \\( c \\), compute$$\\frac{f_1(\\theta=0)}{f_2(\\theta=0)} = \\frac{e^{i0}}{\\cos(0) + i\\sin(0)} = 1$$$$\\frac{f_1(\\theta)}{f_2(\\theta)} = 1 \\implies f_1(\\theta) = f_2(\\theta)$$$$\\therefore e^{i\\theta} = \\cos(\\theta) + i\\sin(\\theta)$$Euler’s Formula in Complex PlaneRun the following code to visualize Euler’s Formula in the complex plane.import numpy as npimport matplotlib.pyplot as plt# Set up a range of theta valuestheta = np.linspace(0, 2*np.pi, 100)# complex exponentialeuler_formula = np.exp(1j * theta)# Create a plotfig, ax = plt.subplots(figsize=(8, 8))ax.plot(np.cos(theta), np.sin(theta), label='Unit Circle $e^{i\\pi} + 1 = 0$')ax.plot(euler_formula.real, euler_formula.imag, label=\"Euler's Formula $e^{i\\\\theta}$\", color='red')# Plot the axis linesax.axhline(0, color='black',linewidth=2)ax.axvline(0, color='black',linewidth=2)# A line from the origin to the point on the circleax.plot([0, np.cos(np.pi/4)], [0, np.sin(np.pi/4)], color='blue', linewidth=2)ax.annotate(r'$e^{i\\pi/4} = {\\cos(\\pi/4) + i\\sin(\\pi/4)}$', xy=(np.cos(np.pi/4)/2, np.sin(np.pi/4)/2), xytext=(0.72, 0.72), fontsize=12)ax.plot([np.cos(np.pi/4), np.cos(np.pi/4)], [0, np.sin(np.pi/4)], color='green', linestyle='--')# Set the limitsax.set_xlim(-1.5, 1.5)ax.set_ylim(-1.5, 1.5)# Place the axis labels right next to the corresponding axisax.text(1.45, 0.05, '${R}$', ha='right', va='center', fontsize=17)ax.text(0, 1.55, '${i}$', ha='center', va='bottom', fontsize=17)# Show the plot without a gridax.grid(False)plt.show()ApplicationsEuler’s IdentityEuler’s Identity is known as the most beautiful equation in mathematics. It is given by:\\[e^{i\\pi} + 1 = 0\\]We can simply verify the identity by substituting \\(\\pi\\) into the Euler’s Formula:\\[e^{i\\pi} = \\cos(\\pi) + i\\sin(\\pi) = -1 + 0 = -1\\]\\[\\therefore e^{i\\pi} + 1 = 0\\]\\(i\\)th Power of \\(i\\), \\(i^i\\)Although sounds paradoxical, the \\(i\\)th power of \\(i\\) is a real number.The expression \\(i^i\\) might seem bizzare at first, but it can be evaluated using Euler’s Formula.The imaginary unit \\( i \\) can be expressed as$$i = 0 + 1i$$This is equivalent to$$i = \\cos\\left(\\frac{\\pi}{2}\\right) + i\\sin\\left(\\frac{\\pi}{2}\\right)$$Using Euler's formula, we can write$$i = e^{i\\frac{\\pi}{2}}$$$$i^i = \\left(e^{i\\frac{\\pi}{2}}\\right)^i$$$$= e^{i^2\\frac{\\pi}{2}}$$$$= e^{-\\frac{\\pi}{2}}$$$$\\therefore i^i = e^{-\\frac{\\pi}{2}} \\approx 0.2079$$\\(\\sin({z}) = 2\\)For those who are not familiar with complex analysis, the equation \\(\\sin({z}) = 2\\) might seem nonsensical. This is true, since \\(\\forall x \\in \\mathbb{R}, -1 \\leq \\sin(x) \\leq 1\\). However, in complex numbers, the sine function can actually exceed the range of \\(-1 \\leq \\sin(x) \\leq 1\\).For example, the equation \\(\\sin({z}) = 2\\) can be solved using Euler’s Formula.\\[\\sin(z) = 2\\]Using Euler's formulas for sine and cosine$$e^{iz} = \\cos(z) + i\\sin(z)$$$$e^{-iz} = \\cos(-z) + i\\sin(-z) = \\cos(z) - i\\sin(z)$$$$e^{iz} -e^{-iz} = 2i\\sin(z)$$Therefore$$\\sin(z) = \\frac{e^{iz} - e^{-iz}}{2i} = 2$$$$e^{iz} - e^{-iz} = 4i$$Expanding the expression$$(e^{iz} - e^{-iz}) \\cdot e^{iz} = 4ie^{iz}$$Which simplifies to$$(e^{iz})^2 - 1 = 4ie^{iz}$$Letting \\( w = e^{iz} \\), we get a quadratic equation$$w^2 - 4iw - 1 = 0$$Using the quadratic formula where \\( a = 1 \\), \\( b = -4i \\), and \\( c = -1 \\)$$w = \\frac{4i \\pm \\sqrt{(-4i)^2 - 4 \\cdot 1 \\cdot (-1)}}{2 \\cdot 1}$$Solving for \\( w \\), we find$$e^{iz} = w = \\frac{4i \\pm 2i\\sqrt{3}}{2} = i(2 \\pm \\sqrt{3})$$Taking the natural logarithm$$iz = \\ln[i(2 \\pm \\sqrt{3})] = \\ln(i) + \\ln(2 \\pm \\sqrt{3})$$Since \\( \\ln(i) = \\ln(e^{i\\frac{\\pi}{2}}) \\)$$iz = i\\frac{\\pi}{2} + \\ln(2 \\pm \\sqrt{3})$$Solving for \\( z \\)$$z = \\frac{\\pi}{2} + \\frac{1}{i} \\ln(2 \\pm \\sqrt{3})$$Therefore$$z = \\frac{\\pi}{2} - i \\ln(2 \\pm \\sqrt{3})$$The equation \\(\\sin(z) = 2\\) yeilds multiple solutions since the sine function is periodic. However, I will finish by the solution \\(z = \\frac{\\pi}{2} - i \\ln(2 \\pm \\sqrt{3})\\) in this post.Other ApplicationsOther than these examples, Euler’s Formula is widely used in various fields such as physics, engineering, omputer science, and more.For example, Euler’s Formula is used for Fourier Transform for signal processing, and in Schrödinger’s equation in quantum mechanics.ConclusionEuler’s Formula seems to be a simple equation, yet it is certainly one of the most powerful and beautiful equations that forms the foundation of modern science and technology.Reference      Math Vault. (n.d.). Euler’s Formula: A Complete Guide. Retrieved February 11, 2024, from https://mathvault.ca/euler-formula/        blackpenredpen. (2017, July 11). Math for fun, sin(z) = 2 [Video]. YouTube. https://youtu.be/3C_XD_cCeeI?si=B84Eg21-TdvViI7L  "
  },
  
  {
    "title": "Python Tutorial - Chapter 1",
    "url": "/posts/Chapter1/",
    "categories": "Python Tutorials",
    "tags": "python",
    "date": "2024-02-09 19:15:00 +0900",
    





    
    "snippet": "Welcome back to Python Tutorial!Click to download a Jupyter Notebook for this chapter!Click here to view all tutorial materialsTopics covered in this chapter:  variables  data types and operations ...",
    "content": "Welcome back to Python Tutorial!Click to download a Jupyter Notebook for this chapter!Click here to view all tutorial materialsTopics covered in this chapter:  variables  data types and operations  print() statement  input() statementPython VariablesVariables are containers for storing data values.Python is a dynamically typed language, which means that you don’t have to declare the type of a variable when you create one.Variables are created when you assign a value to it.In an empty code cell, type the following code:x = 5y = \"Hello, World!\"Contratulations! You have created your first Python variable.In a box called x, you have stored the value 5. In another box called y, you have stored the value \"Hello, World!\".Now try to print the value of x and y using the print() statement.x = 5y = \"Hello, World!\"print(x)print(y)5Hello, World!Variables are newly created if you assign a new value to it.For example:x = 5x = 10print(x)The output of the code above will be 10, because the value of x has been updated to 10.Also, x = x + 1 is a valid statement in Python. It means that the value of x will be updated to x + 1.x = 5x = x + 1 # x = 5 + 1print(x)The output of the code above will be 6.x = 5print(x) # 5x = 10print(x) # 10x = x + xprint(x) # 2051020Practice Problem:Using only one variable called ‘var’, write a code that will output the following:110PythonAnswervar = 1print(var)var = 10print(var)var = \"Python\"print(var)Data Types and OperationsData types are the classification or categorization of data items. It represents the kind of value that tells what operations can be performed on a particular data.Python has the following data types built-in by default, in these categories:  Text Type: str (string)  Numeric Types: int (integer), float (floating point number)  Sequence Types: list, tuple, range  Mapping Type: dict (dictionary)  Set Types: set, frozenset  Boolean Type: bool (boolean)In this tutorial, we will cover the following data types:  int (integer)  float (floating point number)  str (string)  bool (boolean)IntegersIntegers are whole numbers, positive or negative, without decimals, of unlimited length.1, 100, -1000, 0 are examples of integers.With integers, you can perform mathematical operations such as addition, subtraction, multiplication, and division.In an empty code cell, type the following code:x = 5y = 10print(x + y) # additionprint(x - y) # subtractionprint(x * y) # multiplicationprint(x / y) # division15-5500.5There are also other operations that you can perform with integers such as floor division, modulus and exponentiation.In an empty code cell, type the following code:x = 5y = 2print(x / y) # plane divisionprint(x % y) # modulusprint(x ** y) # exponentiationprint(x // y) # floor division2.51252FloatsFloats are real numbers, positive or negative, containing one or more decimals.1.5, 123.456, -1000.0, 0.0 are examples of floats.With floats, you can perform the same mathematical operations as integers.You can also mix integers and floats in the same operation.x = 10y = 5.5print(x + y) # additionprint(x - y) # subtractionprint(x * y) # multiplicationprint(x / y) # divisionprint(x // y) # floor divisionprint(x ** y) # exponentiationprint(x % y) # modulus15.54.555.01.81818181818181811.0316227.76601683794.5StringsStrings are sequences of characters, enclosed in single or double quotes.\"Hello, World!\", 'Python', '123' are examples of strings.Note that even though the value '123' looks like a number, it is actually a string because it is enclosed in quotes.You cannot perform mathematical operations with strings, but you can perform string operations such as concatenation and repetition.Therefore, you cannot mix strings with integers or floats in the same operation.In an empty code cell, type the following code:x = \"Hello, \"y = \"World!\"print(x + y) # concatenationprint(x * 3) # repetitionprint(x + 3) # errorHello, World!Hello, Hello, Hello,Quiz: What will be the output of this code?x = 100y = 200print(x + y)x = \"100\"y = \"200\"print(x + y)x = 100y = \"200\"print(x + y)BooleansBooleans represent one of two values: True or False.Booleans are used to evaluate conditions.We will come back to booleans in the future chapter.# Exaple of Booleanprint(10 != 9) # not equalprint(10 == 9) # equalTrueFalseChecking Data TypesYou can check the data type of a variable using the type() function.In an empty code cell, type the following code:num = 5word = \"Hello, World!\"pi = 3.14cond = Trueprint(type(num))print(type(word))print(type(pi))print(type(cond))Conversion between Data TypesYou can convert between data types using the following functions:  int()  float()  str()  bool()x = 5print(type(x)) # intx = float(20)print(x) # 20.0print(type(x)) # floatx = str(3.14)print(x) # '3.14'print(x * 2) # '3.143.14'print(type(x)) # strx = bool(0)y = bool(1)print(x) # Falseprint(y) # True&lt;class 'int'&gt;20.0&lt;class 'float'&gt;3.143.143.14&lt;class 'str'&gt;FalseTrueprint() statementThe print() statement is used to display the output of a code.Normal print() statementIn an empty code cell, type the following code:x = 5print(\"The value of x is\", x)You can also use the + operator to concatenate strings in the print() statement.In an empty code cell, type the following code:x = 5print(\"The value of x is \" + str(x))f-stringYou can also use the f-string to format the output of the print() statement.In an empty code cell, type the following code:x = 5print(f\"The value of x is {x}\")name = \"John\"age = 25print(f\"Hello, my name is {name} and I am {age} years old.\")Escape CharactersYou can use the following escape characters in the print() statement:  \\n - new line  \\t - tab  \\\\ - backslash  \\\" - double quote  \\' - single quoteIn an empty code cell, type the following code:print(\"Hello\\nWorld!\")print(\"Hello\\tWorld!\")print(\"Hello\\\\World!\")print(\"Hello\\\"World!\")print(\"Hello\\'World!\")HelloWorld!Hello\tWorld!Hello\\World!Hello\"World!Hello'World!input() statementThe input() statement is used to get input from the user.In an empty code cell, type the following code:name = input(\"Enter your name: \")print(\"Hello, \" + name)The input() statement will display the message “Enter your name: “ and wait for the user to input a value. The value will be stored in the variable name.By default, the value of input() is a string. If you want to convert it to an integer or a float, you can use the int() or float() function.for example:num1 = input(\"Enter a number: \")num2 = input(\"Enter another number: \")print(num1 + num2)This code will not work as expected because the value of num1 and num2 are strings. You need to convert them to integers or floats.num1 = int(input(\"Enter a number: \"))num2 = int(input(\"Enter another number: \"))print(num1 + num2)Practice ProblemsProblems      Write a simple calculator that receives two numbers from the user and outputs the sum, difference, product, and quotient of the two numbers in a follwoing format:    Enter the first number: 5Enter the second number: 10    The sum of 5 and 10 is 15.    The difference of 5 and 10 is -5.    The product of 5 and 10 is 50.    The quotient of 5 and 10 is 0.5.        Write a code that will receive the radius of a circle from the user and output the area and circumference of the circle in the following format:  Area = πr^2, Circumference = 2πrEnter the radius of the circle: 5The area of the circle is 78.5.The circumference of the circle is 31.4.  Time travel to Thailand?After a long trip, you and your friends finally arrived to Thailand for your summer vacation. At Suvarnabhumi International Airport, you and your friends are surprised that the year is 2567, not 2024.This is because Thailand uses the Buddhist calendar, which is 543 years ahead of the Gregorian calendar.Write a code that will receive the current year from the user and output the year in the Gregorian calendar in the following format:Enter the current year: 2567The current year in the Gregorian calendar is 2024.  Money exchangeAfter arriving to Thailand, you and your friends need to exchange your money to Thai Baht.Your crew discovered a money exchange booth that exchanges 1 US dollar to 35 Thai Baht.The money exchange booth also charges a 5% fee for every transaction.Write a code that will receive the amount of US dollars from the user and output the amount of Thai Baht that you will receive after the transaction in the following format:Enter the amount of US dollars: 100You will receive 3325 Thai Baht after the transaction.Solutions# Problem 1num1 = int(input(\"Enter the first number: \"))num2 = int(input(\"Enter the second number: \"))print(f\"The sum of {num1} and {num2} is {num1 + num2}.\")print(f\"The difference of {num1} and {num2} is {num1 - num2}.\")print(f\"The product of {num1} and {num2} is {num1 * num2}.\")print(f\"The quotient of {num1} and {num2} is {num1 / num2}.\")# Problem 2radius = float(input(\"Enter the radius of the circle: \"))area = 3.14 * radius ** 2circumference = 2 * 3.14 * radiusprint(f\"The area of the circle is {area}.\")print(f\"The circumference of the circle is {circumference}.\")# Problem 3year = int(input(\"Enter the current year: \"))gregorian_year = year - 543print(f\"The current year in the Gregorian calendar is {gregorian_year}.\")# Problem 4us_dollars = float(input(\"Enter the amount of US dollars: \"))thai_baht = us_dollars * 35thai_baht -= thai_baht * 0.05print(f\"You will receive {thai_baht} Thai Baht after the transaction.\")"
  },
  
  {
    "title": "Vector Integral Theorems Summary",
    "url": "/posts/MultiIntegrals/",
    "categories": "Mathematics, Calculus",
    "tags": "vector, integral, math, multivariable, calculus",
    "date": "2024-02-09 00:23:00 +0900",
    





    
    "snippet": "IntroductionIn this post, I will be introducing the extension of the fundamental theorem of calculus, and the summary of the useful theorems for integrals in vector field: Green’s Theorem, Divergen...",
    "content": "IntroductionIn this post, I will be introducing the extension of the fundamental theorem of calculus, and the summary of the useful theorems for integrals in vector field: Green’s Theorem, Divergence Theorem, and Stokes’ TheoremPrerequsites:  Undersatnding in multivariable integrals  Understanding in Vector Field  Understanding in gradient of multivarible functions  Understanding in Curl and Divergence of Vector FieldFundamental Theorem of Line IntegralsIf a vector field \\(\\vec{F}\\) is conservative, then the line integral through a curve \\(C\\) depends only on the endpoints of \\(C\\). Mathematically, this can be expressed as:\\[\\int_C \\vec{F} \\cdot d\\vec{r} = f(\\vec{r}(b)) - f(\\vec{r}(a))\\]where \\(f\\) is the potential function for \\(\\vec{F}\\).The theorem is particularly useful in physics when calculating work done by a force field in moving an object along a path.Green’s TheoremLet \\(C\\) be a positively oriented, piecewise smooth, simple, closed curve, and let \\(\\vec{F}\\) be a vector field where \\(\\vec{F}(x, y) = \\langle M(x, y), N(x, y) \\rangle\\). Let \\(D\\) be the region enclosed by the curve. If \\(M\\) and \\(N\\) have continuous first-order partial derivatives on \\(D\\), then Green’s Theorem states:\\[\\oint_C (M dx + N dy) = \\iint_D \\left(\\frac{\\partial N}{\\partial x} - \\frac{\\partial M}{\\partial y}\\right) dA = \\iint_D (\\nabla \\times \\vec{F}) \\cdot \\vec{k} \\, dA\\]where \\(M\\) and \\(N\\) are functions of \\(x\\) and \\(y\\) with continuous partial derivatives in \\(D\\). Green’s Theorem can be applied to determine the circulation and flux of a fluid across a region.Divergence TheoremLet \\(E\\) be a simple solid region and \\(S\\) be the boundary surface of \\(E\\) with positive orientation. Let \\(\\vec{F}\\) be a vector field whose components have continuous first-order partial derivatives. Then,\\[\\iint_{S} \\vec{F} \\cdot d\\vec{S} = \\iiint_{E} \\text{div} \\vec{F} \\, dV\\]This applies, for example, to calculating the net flow of fluid through a surface.Stokes’ TheoremLet \\(S\\) be an oriented smooth surface that is bounded by a simple, closed, smooth boundary curve \\(C\\) with positive orientation. Also let \\(\\vec{F}\\) be a vector field then,\\[\\oint_{C} \\vec{F} \\cdot d\\vec{r} = \\iint_{S} \\text{curl} \\vec{F} \\cdot d\\vec{S}\\]Stokes’ Theorem allows analysis of rotational effects in fluid flow or magnetic fields.ApplicationsIn this section, I will provide a detailed example of the situation where one of the theorems can be applied. Consider a situation of analyzing airflow in a room with an air conditioning system. By representing the airflow with a velocity field \\(\\vec{F}\\), the divergence \\(\\nabla \\cdot \\vec{F}\\) quantifies the net airflow rate out of a volume. Integrating this over the room’s volume \\(V\\) gives the total airflow rate, which, by the Divergence Theorem, equals the flux through the room’s boundary surface \\(S\\):\\[\\iiint_{V} (\\nabla \\cdot \\vec{F}) \\, dV = \\iint_{S} \\vec{F} \\cdot d\\vec{S}\\]The left side of the equation represents the total source strength within the room, while the right side represents the total airflow across the room’s boundary. This can help in designing efficient ventilation systems by ensuring the balance between the air introduced and the air exhausted, thus maintaining air quality and proper pressurization."
  },
  
  {
    "title": "Big O Notation",
    "url": "/posts/BigO/",
    "categories": "Programming, Algorithm",
    "tags": "algorithm, programming, math, c++",
    "date": "2024-02-09 00:23:00 +0900",
    





    
    "snippet": "This is a second post in Algorithm series.In this post, we’ll explore the concept of Big O notation, common time complexities, and visualize how these complexities grow as the input size increases....",
    "content": "This is a second post in Algorithm series.In this post, we’ll explore the concept of Big O notation, common time complexities, and visualize how these complexities grow as the input size increases.IntroductionTime and Space ComplexityAlgorithms are crucial part of any program, and good a programmer chooses the most efficient algorithm to solve a problem.To analyze the efficiency of an algorithm, there are two big considerations:      Time Complexity - a measure of the amount of time an algorithm takes to run, in relation to the size of the input data.        Sapce Complexity - a measure of the amount of computer memory (or space) an algorithm needs to run to completion.  Why do algorithms matter?ExampleConsider a simple problem: calculating the sum of all numbers up to an integer n.\\[\\sum_{i=1}^{n} i = \\frac{n(n + 1)}{2}\\]Solution 1: Efficient Algorithmdef sum(n):    return (n * (n+1)) / 2Solution 2: Inefficient Algorithmdef sum(n):    sum = 0    for i in range(1, n+1):        sum += i    return sumThe first solution does not take any memory space as there is no variable assignment involved in the solution.Also, regardless of how large the input n is, the code will just execute a simple mathematical expression.On the other hand, the second solution requires a memory space to save the variable sum, and it executes the addition inside the for loop n times.The difference between the performances of the two solutions might be subtle when n is small, yet as n becomes larger, the difference will grow and be noticeable.Choosing a good algorithm is a must to optimize the performance and efficiency of a program.In the real world, poor efficiency will result in taking up more resources, and thus, more cost.Big O Notation enables programmers to analyze the complexity and the efficiency of an algorithm.DefinitionBig O notation is a mathematical notation that describes the limiting behavior of a function when the argument tends towards a particular value or infinity. In computer science, it is used to analyze the efficiency of algorithms and estimate their worst-case time complexity.Formal DefinitionLet $f(n)$ and $g(n)$ be functions mapping positive integers to positive real numbers. We say that $f(n)$ is $O(g(n))$, read as “f of n is big O of g of n”, if and only if there exist positive constants $c$ and $n_0$ such that:for all $n \\geq n_0$, \\(f(n) \\leq c \\cdot g(n)\\)This means that $f(n) = O(g(n))$ indicates that the growth rate of $f(n)$ is bounded above by the growth rate of $g(n)$ up to a constant factor, for sufficiently large $n$. This notation is used to classify algorithms according to their running time or space requirements in the worst-case scenario.Common Time ComplexitiesCommon Time Complexities include the following:  Constant time  Linear time  Logarithmic time  Linearithmic time  Quadratic time  Exponential time$O({1})$ - Constant Time$O({1})$ represents algorithms that always execute in the same time (or space) regardless of the size of the input data.Example: Accessing a specific element in an array.#include &lt;iostream&gt;int main(){    int myArray[] = {1, 2, 3, 4, 5};    std::cout &lt;&lt; myArray[0]; // returns the first element regardless of the size of the array    return 0;}$O(n)$ - Linear Time$O(n)$ represents algorithms whose performance grows linearly and in direct proportion to the size of the input data set.Example: Traversing an array.#include&lt;iostream&gt;int main(){    int myArray[] = {1, 2, 3, 4, 5};    for(int i = 0; i &lt; 5; i++) {        std::cout &lt;&lt; myArray[i]; // prints each element in the array    }    return 0;}$O(\\log n)$ - Logarithmic TimeLogarithmic time complexity $O(\\log n)$ describes an algorithm that reduces the size of its input data by a significant fraction (usually half) with each step, leading to fewer steps as the input size grows.Example: Binary search in a sorted array.#include &lt;bits/stdc++.h&gt;using namespace std;int binarySearch(int arr[], int l, int r, int x){    while (l &lt;= r) {        int m = l + (r - l) / 2;        if (arr[m] == x)            return m;        if (arr[m] &lt; x)            l = m + 1;        else            r = m - 1;    }    return -1;}int main(void){    int arr[] = { 2, 3, 4, 10, 40 };    int x = 10;    int n = sizeof(arr) / sizeof(arr[0]);    int result = binarySearch(arr, 0, n - 1, x);    (result == -1)        ? cout &lt;&lt; \"Element is not present in array\"        : cout &lt;&lt; \"Element is present at index \" &lt;&lt; result;    return 0;}$O(n\\log n)$ - Linearithmic TimeLinearithmic time complexity $O(n\\log n)$ represents algorithms where the time grows in proportion to $n \\log n$, combining linear and logarithmic behavior. This complexity is common in efficient sorting algorithms.Example: Merge Sort algorithm.#include &lt;bits/stdc++.h&gt;using namespace std;void merge(int array[], int const left, int const mid,\t\tint const right){\tint const subArrayOne = mid - left + 1;\tint const subArrayTwo = right - mid;\tauto *leftArray = new int[subArrayOne],\t\t*rightArray = new int[subArrayTwo];\tfor (auto i = 0; i &lt; subArrayOne; i++)\t\tleftArray[i] = array[left + i];\tfor (auto j = 0; j &lt; subArrayTwo; j++)\t\trightArray[j] = array[mid + 1 + j];\tauto indexOfSubArrayOne = 0, indexOfSubArrayTwo = 0;\tint indexOfMergedArray = left;\twhile (indexOfSubArrayOne &lt; subArrayOne\t\t&amp;&amp; indexOfSubArrayTwo &lt; subArrayTwo) {\t\tif (leftArray[indexOfSubArrayOne]\t\t\t&lt;= rightArray[indexOfSubArrayTwo]) {\t\t\tarray[indexOfMergedArray]\t\t\t\t= leftArray[indexOfSubArrayOne];\t\t\tindexOfSubArrayOne++;\t\t}\t\telse {\t\t\tarray[indexOfMergedArray]\t\t\t\t= rightArray[indexOfSubArrayTwo];\t\t\tindexOfSubArrayTwo++;\t\t}\t\tindexOfMergedArray++;\t}\twhile (indexOfSubArrayOne &lt; subArrayOne) {\t\tarray[indexOfMergedArray]\t\t\t= leftArray[indexOfSubArrayOne];\t\tindexOfSubArrayOne++;\t\tindexOfMergedArray++;\t}\twhile (indexOfSubArrayTwo &lt; subArrayTwo) {\t\tarray[indexOfMergedArray]\t\t\t= rightArray[indexOfSubArrayTwo];\t\tindexOfSubArrayTwo++;\t\tindexOfMergedArray++;\t}\tdelete[] leftArray;\tdelete[] rightArray;}void mergeSort(int array[], int const begin, int const end){\tif (begin &gt;= end)\t\treturn;\tint mid = begin + (end - begin) / 2;\tmergeSort(array, begin, mid);\tmergeSort(array, mid + 1, end);\tmerge(array, begin, mid, end);}void printArray(int A[], int size){\tfor (int i = 0; i &lt; size; i++)\t\tcout &lt;&lt; A[i] &lt;&lt; \" \";\tcout &lt;&lt; endl;}int main(){\tint arr[] = { 12, 11, 13, 5, 6, 7 };\tint arr_size = sizeof(arr) / sizeof(arr[0]);\tcout &lt;&lt; \"Given array is \\n\";\tprintArray(arr, arr_size);\tmergeSort(arr, 0, arr_size - 1);\tcout &lt;&lt; \"\\nSorted array is \\n\";\tprintArray(arr, arr_size);\treturn 0;}$O(n^2)$ - Quadratic TimeQuadratic time complexity $O(n^2)$ indicates that the time taken by an algorithm is proportional to the square of the input size. It is common in algorithms that perform nested iterations over the data set.Example: Bubble sort algorithm.#include &lt;bits/stdc++.h&gt;using namespace std;void bubbleSort(int arr[], int n){\tint i, j;\tbool swapped;\tfor (i = 0; i &lt; n - 1; i++) {\t\tswapped = false;\t\tfor (j = 0; j &lt; n - i - 1; j++) {\t\t\tif (arr[j] &gt; arr[j + 1]) {\t\t\t\tswap(arr[j], arr[j + 1]);\t\t\t\tswapped = true;\t\t\t}\t\t}\t\tif (swapped == false)\t\t\tbreak;\t}}void printArray(int arr[], int size){\tint i;\tfor (i = 0; i &lt; size; i++)\t\tcout &lt;&lt; \" \" &lt;&lt; arr[i];}int main(){\tint arr[] = { 64, 34, 25, 12, 22, 11, 90 };\tint N = sizeof(arr) / sizeof(arr[0]);\tbubbleSort(arr, N);\tcout &lt;&lt; \"Sorted array: \\n\";\tprintArray(arr, N);\treturn 0;}$O(2^n)$ - Exponential TimeExponential time complexity $O(2^n)$ describes an algorithm whose growth doubles with each addition to the input data set. This complexity is typical in brute-force algorithms for solving complex problems.Example: Fibonacci sequence using recursion.#include &lt;iostream&gt;int fibonacci(int n) {    if (n &lt;= 1)        return n;    return fibonacci(n - 1) + fibonacci(n - 2);}int main() {    int n = 10;    std::cout &lt;&lt; \"Fibonacci number is \" &lt;&lt; fibonacci(n);    return 0;}* The detailed observation into the algorithms introduced in this part will be posted laterVisualization of the Time Complexitiesimport matplotlib.pyplot as pltimport numpy as npn = np.arange(1, 100)plt.figure(figsize=(10, 6))# O(1)plt.plot(n, np.ones_like(n), label='$O(1)$', linestyle='--')# O(n)plt.plot(n, n, label='$O(n)$')# O(log n)plt.plot(n, np.log(n), label='$O(\\log n)$')# O(n log n)plt.plot(n, n*np.log(n), label='$O(n \\log n)$')# O(n^2)plt.plot(n, n**2, label='$O(n^2)$')# O(2^n)plt.plot(n, 2**n, label='$O(2^n)$')plt.title('Common Time Complexities')plt.xlabel('Input Size (n)')plt.ylabel('Operations')plt.grid(True)plt.legend()plt.yscale('log')plt.ylim(0, 10000)plt.show()ConclusionAnalyzing the efficiency of an algorithm is a necessary process for making informed decisions when designing a program. Big O notation is a useful strategy for investigating the time and space complexity of an algorithm, and thus, understanding Big O notation is crucial for developers and programmers to optimize the performance of their programs.References      Modeling Social Data. (2017, February 3). Lecture 3: Computational Complexity. Retrieved February 9, 2024, from https://modelingsocialdata.org/lectures/2017/02/03/lecture-3-computational-complexity.html        GeeksforGeeks. (n.d.). Binary Search. Retrieved February 9, 2024, from https://www.geeksforgeeks.org/binary-search/        GeeksforGeeks. (n.d.). Merge Sort. Retrieved February 9, 2024, from https://www.geeksforgeeks.org/merge-sort/        GeeksforGeeks. (n.d.). Bubble Sort. Retrieved February 9, 2024, from https://www.geeksforgeeks.org/bubble-sort/  "
  },
  
  {
    "title": "Python Tutorial - Chapter 0",
    "url": "/posts/Chapter0/",
    "categories": "Python Tutorials",
    "tags": "python",
    "date": "2024-02-08 13:23:00 +0900",
    





    
    "snippet": "Welcome to Python Tutorial!There are many Human Languages, such as English, Korean, Spanish, Chinese, etc.Just Like humans, computers also have different languages for communication, such as C/C++,...",
    "content": "Welcome to Python Tutorial!There are many Human Languages, such as English, Korean, Spanish, Chinese, etc.Just Like humans, computers also have different languages for communication, such as C/C++, Assembly, Java, JavaScript, and Python.Why Python?Interpreter V.S. CompilerComputers fundamentally only understand languages written with 0 and 1, often referred to as “Machine Language”. No matter what language programmers code in, there must be a process of converting that into machine language. This conversion is done by either an interpreter or a compiler.Two popular examples of these types of languages are C (a compiled language) and Python (an interpreted language). Compiled languages like C usually perform faster, but they can be more difficult to code and debug.Python, on the other hand, is an interpreted language. This means that it is relatively easy to write and fix errors in Python. The interpreter executes the code line by line, which allows for more immediate feedback and easier debugging. This is one of the reasons why Python is popular for beginners and for rapid development.Easy to LearnPython is easy to learn for several reasons.      Readability: Python’s syntax is designed to be readable and straightforward. This makes it easier for beginners to pick up the language and understand what the code is doing.        High-level language: Python is a high-level language, meaning it abstracts many of the complex details of the computer. This allows beginners to start coding without needing to understand complex computer science concepts.        Large Standard Library: Python comes with a large standard library that covers many areas, from web development to machine learning. This means beginners can do a lot with Python without needing to understand or use external libraries.        Strong Community: Python is an open source and has a large and supportive community. This means there are plenty of resources available for learning and troubleshooting, from online tutorials to forums and Q&amp;A websites.  For example, these are the codes for printing “Hello World!” in three different languages.C++#include &lt;iostream&gt;using namespace std;int main() {    cout &lt;&lt; \"Hello World!\";    return 0;}Javapublic class HelloWorld {    public static void main(String[] args) {        System.out.println(\"Hello World!\");    }}Pythonprint(\"Hello World!\")Wide UsecasesPython has gained its popularity because of its wide range of domains.Python is useful for these tasks:  Web development  Data Science / Data Analysis  Machine Learning  Artificial IntelligencePopular programs developed with Python:  YouTube  Google  Instagram  Spotify  AmazonInstallationWe will be using Jupyter Notebook for this tutorial.What is a Jupyter Notebook?Jupyter Notebook is an interactive web application for creating and sharing computational documents.It is useful to write and run Python codes on a web environment without sophisticated setup process.Install AnacondaTo setup the device, please visit the website andInstall Anaconda.Anaconda is a useful tool that automatically install all the softwares required for writing Python code in Jupyter Notebook.Launch Jupyter NotebookAfter the installation is completed, open the Anaconda panel and find Jupyter Notebook to launch the program.Choose DirectoryGo to the directory where you want to store the tutorial materials.Click new button on the top right corner, and choose Python 3 kernal.Writing the first codeNow, let’s write our first Python code.In the first code cell, type the following codeprint(\"Hello, Python!\")and press shift + enter to run the code.Hello, Python!If you see the text printed, the software is successfully installed.“The only way to learn a new programming language is by writing programs in it.”- Dennis Ritchie"
  },
  
  {
    "title": "Recursion",
    "url": "/posts/Recursion/",
    "categories": "Programming, Algorithm",
    "tags": "algorithm, programming, python, recursion",
    "date": "2024-02-08 00:23:00 +0900",
    





    
    "snippet": "This is a first post in Algorithm series.Recursion in algorithms is a method where a problem is solved by breaking it down into smaller instances of the same problem. This approach involves a funct...",
    "content": "This is a first post in Algorithm series.Recursion in algorithms is a method where a problem is solved by breaking it down into smaller instances of the same problem. This approach involves a function calling itself with a smaller input until it reaches a condition known as the base case, which is simple enough to be solved directly. Once the base case is reached, the solution to that base case is used to solve the other instances of the problem, building up to the solution of the original problem.  The base case is the condition to stop the recursion  The recursive case is the part where the function calls on itself.print 1 to 10 using recursive functionwithout recursion, the code would look like this:for i in range(11):    print(i)012345678910same task done with recursion:def printNum(n = 1):    if n &gt; 10: #This is a base case        return    else: # This is a recursive case        print(n)        printNum(n + 1)printNum()12345678910Factorialfactorial is a function that multiplies a number by every number below it till 1without recursion:n = 6num = 1for i in range(n):    num *= n    n -= 1print(num)720with recursion:def Factorial(n):    num = 1    if n &lt; 0: # This is a Boundary Case        raise ValueError(\"The input must be a non-negative integer\")    elif n &lt;= 1: # This is a base case        return 1    else: # This is a recursive case        return n * Factorial(n - 1)print(Factorial(6))720FibonacciFibonacci sequence is a sequence in which each number is the sum of the two preceding ones.without recursion:n = 6a_1 = 0a_2 = 1for i in range(n - 1):    a_1, a_2 = a_2, a_1 + a_2print(a_2)8def Fibonacci(n):    if n == 0: # This is a base case        return 0    elif n == 1: # This is another base case        return 1    elif n &gt; 1: # This is a recursive case        return Fibonacci(n - 1) + Fibonacci(n - 2)    else: # This is a boundary case        raise ValueError(\"Negative integer is invalid\")print(Fibonacci(6))“To understand recursion, one must first understand recursion.”-Stephen Hawking-"
  }
  
]

